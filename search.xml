<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java数据结构和算法——稀疏矩阵</title>
    <url>/2020/02/03/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191216/Q8uEsQH3g5hV.jpg?imageslim" alt="mark"></p>
<a id="more"></a> 

<h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191216/c57v4gQbgVoF.png?imageslim" alt="mark"></p>
<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p>
<p>稀疏数组的处理方法是:</p>
<ol>
<li><p>记录数组一共有几行几列，有多少个不同的值</p>
</li>
<li><p>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</p>
</li>
</ol>
<h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)<br>把稀疏数组存盘，并且可以从新恢复原来的二维数组数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建一个原始的二维数组 11 * 11</span></span><br><span class="line">		<span class="comment">// 0: 表示没有棋子， 1 表示 黑子 2 表蓝子</span></span><br><span class="line">		<span class="keyword">int</span> chessArr1[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">		chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">		chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">		chessArr1[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line">		chessArr1[<span class="number">6</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 输出原始的二维数组</span></span><br><span class="line">		System.out.println(<span class="string">"原始的二维数组~~"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr1) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">				System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将二维数组 转 稀疏数组的思</span></span><br><span class="line">		<span class="comment">// 1. 先遍历二维数组 得到非0数据的个数</span></span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">					sum++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 创建对应的稀疏数组</span></span><br><span class="line">		<span class="keyword">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">		<span class="comment">// 给稀疏数组赋值</span></span><br><span class="line">		sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">		sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">		sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 遍历二维数组，将非0的值存放到 sparseArr中</span></span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//count 用于记录是第几个非0数据</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">					count++;</span><br><span class="line">					sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">					sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">					sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 输出稀疏数组的形式</span></span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(<span class="string">"得到稀疏数组为~~~~"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"%d\t%d\t%d\t\n"</span>, sparseArr[i][<span class="number">0</span>], sparseArr[i][<span class="number">1</span>], sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将稀疏数组 --》 恢复成 原始的二维数组</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 *  1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 = int [11][11]</span></span><br><span class="line"><span class="comment">			2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">			chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 输出恢复后的二维数组</span></span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(<span class="string">"恢复后的二维数组"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr2) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">				System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<p><img src="image-20191205193140618.png" alt="image-20191205193140618.png"></p>
<h3 id="习题要求"><a href="#习题要求" class="headerlink" title="习题要求"></a>习题要求</h3><ol>
<li>在前面的基础上，将稀疏数组保存到磁盘上，比如 map.data</li>
<li>恢复原来的数组时，读取map.data 进行恢复</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.sparsearray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.print.DocFlavor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 创建一个原始的二维数组 11 * 11</span></span><br><span class="line">		<span class="comment">// 0: 表示没有棋子， 1 表示 黑子 2 表蓝子</span></span><br><span class="line">		<span class="keyword">int</span> chessArr1[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">		chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">		chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">		chessArr1[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line">		chessArr1[<span class="number">6</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 输出原始的二维数组</span></span><br><span class="line">		System.out.println(<span class="string">"原始的二维数组~~"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr1) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">				System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将二维数组 转 稀疏数组的思</span></span><br><span class="line">		<span class="comment">// 1. 先遍历二维数组 得到非0数据的个数</span></span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">					sum++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 创建对应的稀疏数组</span></span><br><span class="line">		<span class="keyword">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">		<span class="comment">// 给稀疏数组赋值</span></span><br><span class="line">		sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">		sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">		sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 遍历二维数组，将非0的值存放到 sparseArr中</span></span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//count 用于记录是第几个非0数据</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">					count++;</span><br><span class="line">					sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">					sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">					sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将稀疏矩阵保存到磁盘上</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 输出稀疏数组的形式</span></span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(<span class="string">"得到稀疏数组为~~~~"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"%d\t%d\t%d\t\n"</span>, sparseArr[i][<span class="number">0</span>], sparseArr[i][<span class="number">1</span>], sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将稀疏数组存储到文件map.data中</span></span><br><span class="line">        saveData(sparseArr);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">//从map.data文件中读取稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] sparseArr1 =getData();</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将稀疏数组 --》 恢复成 原始的二维数组</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 *  1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 = int [11][11]</span></span><br><span class="line"><span class="comment">			2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr1[<span class="number">0</span>][<span class="number">0</span>]][sparseArr1[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr1.length; i++) &#123;</span><br><span class="line">			chessArr2[sparseArr1[i][<span class="number">0</span>]][sparseArr1[i][<span class="number">1</span>]] = sparseArr1[i][<span class="number">2</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 输出恢复后的二维数组</span></span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(<span class="string">"恢复后的二维数组"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr2) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">				System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">saveData</span><span class="params">(<span class="keyword">int</span>[][] arr)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">	        </span><br><span class="line">	        File file = <span class="keyword">new</span> File(<span class="string">"I:\\eclipse-workspace\\DataStructures\\map.data"</span>);</span><br><span class="line">	        PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(file));</span><br><span class="line">	        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; arr.length; i++)&#123;</span><br><span class="line">	            pw.println(arr[i][<span class="number">0</span>]+<span class="string">","</span>+arr[i][<span class="number">1</span>]+<span class="string">","</span>+arr[i][<span class="number">2</span>]);</span><br><span class="line">	            pw.flush();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getData()<span class="keyword">throws</span> IOException&#123;</span><br><span class="line">	 </span><br><span class="line">	        File file = <span class="keyword">new</span> File(<span class="string">"I:\\eclipse-workspace\\DataStructures\\map.data"</span>);</span><br><span class="line">	        FileReader fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">	        BufferedReader br = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">	        String len=br.readLine();</span><br><span class="line">	        String[] str = len.split(<span class="string">","</span>);</span><br><span class="line">	        <span class="keyword">int</span>[][] ch = <span class="keyword">new</span>  <span class="keyword">int</span>[Integer.parseInt(str[<span class="number">2</span>])+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">	        ch[<span class="number">0</span>][<span class="number">0</span>] = Integer.parseInt(str[<span class="number">0</span>]);</span><br><span class="line">	        ch[<span class="number">0</span>][<span class="number">1</span>] = Integer.parseInt(str[<span class="number">1</span>]);</span><br><span class="line">	        ch[<span class="number">0</span>][<span class="number">2</span>] = Integer.parseInt(str[<span class="number">2</span>]);</span><br><span class="line">	        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">	        <span class="keyword">while</span>((len=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">	            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">	                String[] str2 = len.split(<span class="string">","</span>);</span><br><span class="line">	                ch[temp][i] = Integer.parseInt(str2[i]);</span><br><span class="line">	            &#125;</span><br><span class="line">	            temp++;</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">return</span> ch;</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<p><img src="image-20191205193101382.png" alt="image-20191205193101382"></p>
<p><img src="image-20191205193155714.png" alt="image-20191205193140618"></p>
]]></content>
  </entry>
  <entry>
    <title>每日一题——用两个队列实现一个栈</title>
    <url>/2020/01/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E7%94%A8%E4%B8%A4%E4%B8%AA%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A0%88/</url>
    <content><![CDATA[<p>题目：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//如果stack2为空，就把stack1的数全都弹到stack2中</span></span><br><span class="line">            <span class="keyword">while</span>(stack1.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：两个栈分别为stack1和stack2，对于入队操作，直接入stack1，对于出队，首先判断stack2是否为空，如果为空，就把stack1中数据依次全部弹入到stack2中，再弹出stack2栈顶元素。</p>
<p>扩展问题：如何用两个队列来模拟一个堆栈呢？</p>
<p>入队</p>
<ol>
<li>判断两个队列（queue1,queue2）哪个为空，如果都为空，直接加入queue1</li>
<li>将数据加入不为空的队列</li>
</ol>
<p>出队</p>
<ol>
<li>选择有数据的那个队列，将其中的数据出队，并加入另一个队列</li>
<li>将原队列中最后一个数据输出</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gaowei.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackWithTwoQueue</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> CircleArrayQueue queue1 = <span class="keyword">new</span> CircleArrayQueue(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">private</span> CircleArrayQueue queue2 = <span class="keyword">new</span> CircleArrayQueue(<span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1. 判断两个队列（queue1,queue2）哪个为空，如果都为空，直接加入queue1</span></span><br><span class="line">	<span class="comment">//2. 将数据加入不为空的队列</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(queue1.isEmpty() &amp;&amp; queue2.isEmpty()) &#123;</span><br><span class="line">			queue1.addQueue(num);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(queue1.isEmpty())&#123;</span><br><span class="line">			queue2.addQueue(num);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(queue2.isEmpty()) &#123;</span><br><span class="line">			queue1.addQueue(num);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1. 选择有数据的那个队列，将其中的数据出队，并加入另一个队列</span></span><br><span class="line">	<span class="comment">//2. 将原队列中最后一个数据输出</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!queue1.isEmpty())&#123;</span><br><span class="line">			<span class="keyword">while</span>(queue1.size() != <span class="number">1</span>) &#123;</span><br><span class="line">				queue2.addQueue(queue1.getQueue());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> queue1.getQueue();</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!queue2.isEmpty())&#123;</span><br><span class="line">			<span class="keyword">while</span>(queue2.size() != <span class="number">1</span>) &#123;</span><br><span class="line">				queue1.addQueue(queue2.getQueue());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> queue2.getQueue();</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"堆栈为空！！！"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!queue1.isEmpty()) &#123;</span><br><span class="line">			queue1.showQueue();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			queue2.showQueue();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java练习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Java语言高级——集合</title>
    <url>/2020/01/10/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E2%80%94%E2%80%94%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java语言高级——枚举与注解</title>
    <url>/2020/01/07/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E2%80%94%E2%80%94%E6%9E%9A%E4%B8%BE%E4%B8%8E%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>a</p>
<a id="more"></a>

<h2 id="Java语言高级——枚举与注解"><a href="#Java语言高级——枚举与注解" class="headerlink" title="Java语言高级——枚举与注解"></a>Java语言高级——枚举与注解</h2><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><h4 id="如何自定义枚举类"><a href="#如何自定义枚举类" class="headerlink" title="如何自定义枚举类"></a>如何自定义枚举类</h4><p><strong>枚举类的属性</strong></p>
<p>枚举类对象的属性不应允许被改动, 所以应该使用 private final 修饰<br>枚举类的使用 private final 修饰的属性应该在构造器中为其赋值<br>若枚举类显式的定义了带参数的构造器, 则在列出枚举值时也必须对应的传入参数</p>
<p><strong>自定义枚举类</strong></p>
<ol>
<li>私有化类的构造器，保证不能在类的外部创建其对象</li>
<li>在类的内部创建枚举类的实例。声明为：public static final</li>
<li>对象如果有实例变量，应该声明为private final，并在构造器中初始化</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Season</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String SEASONNAME;<span class="comment">//季节的名称</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String SEASONDESC;<span class="comment">//季节的描述</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName,String seasonDesc)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.SEASONNAME = seasonName;</span><br><span class="line">	<span class="keyword">this</span>.SEASONDESC = seasonDesc;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING = <span class="keyword">new</span> Season(<span class="string">"春天"</span>, <span class="string">"春暖花开"</span>);</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER = <span class="keyword">new</span> Season(<span class="string">"夏天"</span>, <span class="string">"夏日炎炎"</span>);</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN = <span class="keyword">new</span> Season(<span class="string">"秋天"</span>, <span class="string">"秋高气爽"</span>);</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER = <span class="keyword">new</span> Season(<span class="string">"冬天"</span>, <span class="string">"白雪皑皑"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="如何使用关键字enum定义枚举类"><a href="#如何使用关键字enum定义枚举类" class="headerlink" title="如何使用关键字enum定义枚举类"></a>如何使用关键字enum定义枚举类</h4><ul>
<li><p>使用说明</p>
<ul>
<li>使用 enum 定义的枚举类默认继承了 java.lang.Enum类，因此不能再 继承其他类</li>
<li>枚举类的构造器只能使用 private 权限修饰符 </li>
<li>枚举类的所有实例必须在枚举类中显式列出(, 分隔 ; 结尾)。列出的 实例系统会自动添加 public static final 修饰</li>
<li>必须在枚举类的第一行声明枚举类对象 </li>
</ul>
</li>
<li><p>JDK 1.5 中可以在 switch 表达式中使用Enum定义的枚举类的对象 作为表达式, case 子句可以直接使用枚举值的名字, 无需添加枚举 类作为限定。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SeasonEnum &#123;</span><br><span class="line">	SPRING(<span class="string">"春天"</span>,<span class="string">"春风又绿江南岸"</span>),	</span><br><span class="line">	SUMMER(<span class="string">"夏天"</span>,<span class="string">"映日荷花别样红"</span>),</span><br><span class="line">	AUTUMN(<span class="string">"秋天"</span>,<span class="string">"秋水共长天一色"</span>),</span><br><span class="line">	WINTER(<span class="string">"冬天"</span>,<span class="string">"窗含西岭千秋雪"</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String seasonName;	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SeasonEnum</span><span class="params">(String seasonName, String seasonDesc)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">		<span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> seasonName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> seasonDesc;</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Enum类的主要方法"><a href="#Enum类的主要方法" class="headerlink" title="Enum类的主要方法"></a>Enum类的主要方法</h4><ul>
<li>values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的 枚举值。 </li>
<li>valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符 串必须是枚举类对象的“名字”。如不是，会有运行时异常： IllegalArgumentException。 </li>
<li>toString()：返回当前枚举类对象常量的名称</li>
</ul>
<h4 id="实现接口的枚举类"><a href="#实现接口的枚举类" class="headerlink" title="实现接口的枚举类"></a>实现接口的枚举类</h4><ul>
<li>和普通 Java 类一样，枚举类可以实现一个或多个接口 </li>
<li>若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只 要统一实现该方法即可。 </li>
<li>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式, 则可以让每个枚举值分别来实现该方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Works</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReflectColor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color implements Works&#123;</span><br><span class="line">    RED(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReflectColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是红色"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">String <span class="title">meaning</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"红色"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    BLUE(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReflectColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是蓝色"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">String <span class="title">meaning</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"蓝色"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    BLACK(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReflectColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是黑色"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">String <span class="title">meaning</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"黑色"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    YELLOW(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReflectColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是黄色"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">String <span class="title">meaning</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"黄色"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    GREEN(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ReflectColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是绿色"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">String <span class="title">meaning</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"绿色"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> redValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> greenValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> blueValue;</span><br><span class="line"></span><br><span class="line">    Color(<span class="keyword">int</span> redValue,<span class="keyword">int</span> greenValue,<span class="keyword">int</span> blueValue) &#123;</span><br><span class="line">        <span class="keyword">this</span>.redValue = redValue;</span><br><span class="line">        <span class="keyword">this</span>.greenValue = greenValue;</span><br><span class="line">        <span class="keyword">this</span>.blueValue = blueValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Color&#123;"</span> +</span><br><span class="line">                <span class="string">"redValue="</span> + redValue +</span><br><span class="line">                <span class="string">", greenValue="</span> + greenValue +</span><br><span class="line">                <span class="string">", blueValue="</span> + blueValue +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> String <span class="title">meaning</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><h4 id="注解-Annotation-概述"><a href="#注解-Annotation-概述" class="headerlink" title="注解(Annotation)概述"></a>注解(Annotation)概述</h4><p>从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是 Annotation(注解) 。Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加 载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员 可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代 码分析工具、开发工具和部署工具可以通过这些补充信息进行验证 或者进行部署。 Annotation 可以像修饰符一样被使用, 可用于修饰包,类, 构造器, 方 法, 成员变量, 参数, 局部变量的声明, 这些信息被保存在 Annotation 的 “name=value” 对中。</p>
<h4 id="常见的Annotation示例"><a href="#常见的Annotation示例" class="headerlink" title="常见的Annotation示例"></a>常见的Annotation示例</h4><h4 id="自定义Annotation"><a href="#自定义Annotation" class="headerlink" title="自定义Annotation"></a>自定义Annotation</h4><h4 id="JDK中的元注解"><a href="#JDK中的元注解" class="headerlink" title="JDK中的元注解"></a>JDK中的元注解</h4><h4 id="利用反射获取注解信息（在反射部分涉及）"><a href="#利用反射获取注解信息（在反射部分涉及）" class="headerlink" title="利用反射获取注解信息（在反射部分涉及）"></a>利用反射获取注解信息（在反射部分涉及）</h4><h4 id="JDK8中注解的新特性"><a href="#JDK8中注解的新特性" class="headerlink" title="JDK8中注解的新特性"></a>JDK8中注解的新特性</h4>]]></content>
      <categories>
        <category>Java高级</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据结构与算法——递归</title>
    <url>/2020/01/03/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<p><img src="http://image.gwbiubiubiu.com/blog/20200106/DGC8ptzo9fEK.jpg" alt="mark"></p>
<a id="more"></a>

<h3 id="Java数据结构与算法——递归"><a href="#Java数据结构与算法——递归" class="headerlink" title="Java数据结构与算法——递归"></a>Java数据结构与算法——递归</h3><p>递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。</p>
<h4 id="递归需要遵守的重要规则"><a href="#递归需要遵守的重要规则" class="headerlink" title="递归需要遵守的重要规则"></a>递归需要遵守的重要规则</h4><ol>
<li><p>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)</p>
</li>
<li><p>方法的局部变量是独立的，不会相互影响, 比如n变量</p>
</li>
<li><p>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.</p>
</li>
<li><p>递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:)</p>
</li>
<li><p>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。</p>
</li>
</ol>
<h3 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gaowei.recursion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Maze</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">			map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">			map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">			map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">			map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">		map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">		System.out.println(<span class="string">"原来地图："</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">				System.out.print(map[i][j] + <span class="string">" "</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		setWay(map, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">		System.out.println(<span class="string">"寻迹后地图："</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">				System.out.print(map[i][j] + <span class="string">" "</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用递归回溯来给小球找路</span></span><br><span class="line">	<span class="comment">// 说明</span></span><br><span class="line">	<span class="comment">// 1. map 表示地图</span></span><br><span class="line">	<span class="comment">// 2. i,j 表示从地图的哪个位置开始出发 (1,1)</span></span><br><span class="line">	<span class="comment">// 3. 如果小球能到 map[6][5] 位置，则说明通路找到.</span></span><br><span class="line">	<span class="comment">// 4. 约定： 当map[i][j] 为 0 表示该点没有走过 当为 1 表示墙 ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通</span></span><br><span class="line">	<span class="comment">// 5. 在走迷宫时，需要确定一个策略(方法) 下-&gt;右-&gt;上-&gt;左 , 如果该点走不通，再回溯</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> map 表示地图</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> i   从哪个位置开始找</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 如果找到通路，就返回true, 否则返回false</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (map[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">				map[i][j] = <span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span> (setWay(map, i + <span class="number">1</span>, j)) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j + <span class="number">1</span>)) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i - <span class="number">1</span>, j)) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j - <span class="number">1</span>)) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					map[i][j] = <span class="number">3</span>;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="http://image.gwbiubiubiu.com/blog/20200106/MUVajwy4oUnt.png" alt="mark"></p>
<h3 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h3><p><strong>问题提出：</strong></p>
<p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gaowei.recursion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queen8</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> MAX = <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[MAX];</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> judgeCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Queen8 queen8 = <span class="keyword">new</span> Queen8();</span><br><span class="line">		queen8.check(<span class="number">0</span>);</span><br><span class="line">		System.out.println(count + <span class="string">" "</span> + judgeCount);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 编写一个方法，放置第n个皇后</span></span><br><span class="line">	<span class="comment">// 特别注意： check 是 每一次递归时，进入到check中都有 for(int i = 0; i &lt; max; i++)，因此会有回溯</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n == MAX) &#123;</span><br><span class="line">			print();</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; i++) &#123;</span><br><span class="line">			array[n] = i;</span><br><span class="line">			<span class="keyword">if</span>(judge(n)) &#123;</span><br><span class="line">				check(n+<span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查看当我们放置第n个皇后, 就去检测该皇后是否和前面已经摆放的皇后冲突</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> n 表示第n个皇后</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		judgeCount++;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 写一个方法，可以将皇后摆放的位置输出</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		count++;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">			System.out.print(array[i] + <span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="http://image.gwbiubiubiu.com/blog/20200106/bpTYSRYV8VR8.png" alt="mark"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>每日一题——多线程打印</title>
    <url>/2020/01/03/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%93%E5%8D%B0/</url>
    <content><![CDATA[<p><img src="http://image.gwbiubiubiu.com/blog/20200103/bYjUV3wAQ6M4.jpg" alt="mark"></p>
<a id="more"></a>

<h5 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h5><p>创建两个线程，其中一个输出<code>1</code>-<code>52</code>，另外一个输出A-Z。输出格式要求：12A 34B 56C 78D …</p>
<h5 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a><strong>输入描述:</strong></h5><p>1、线程1打印1-52的数字2、线程2打印26个字母</p>
<h5 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h5><p>每打印两个数字后打印一个字母，直到最终所有数字和字母都打印完成</p>
<h5 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h5><p>定义两个类，分别继承Thread或实现Runnable。其中一个类中的run方法用于输出数字，当输出数字为偶数时wait，进入等待队列，且使用notify唤醒其他线程；另一个类中输出字母，每输出一个字母后，wait进入等待队列，且使用notify唤醒其他线程。两个类的run方法都使用同步代码块，对同一个对象加锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exe1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object object = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread1(object)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Thread2(object)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread1</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(object)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">52</span>; i++)&#123;</span><br><span class="line">                System.out.print(i);</span><br><span class="line">                <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    object.notifyAll();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        object.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread2</span><span class="params">(Object object)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(object)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> i =<span class="string">'A'</span>; i &lt;= <span class="string">'Z'</span>; i++)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                object.notifyAll();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    object.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="string">'Z'</span>)&#123;</span><br><span class="line">                object.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实现结果"><a href="#实现结果" class="headerlink" title="实现结果"></a>实现结果</h5><p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20200103/6DB3sNltGTSu.png" alt="mark"></p>
]]></content>
      <categories>
        <category>Java练习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Java语言高级——常用类</title>
    <url>/2019/12/31/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E2%80%94%E2%80%94%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
    <content><![CDATA[<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191231/r3HV0udurzYR.jpg" alt="mark"></p>
<a id="more"></a>

<h2 id="Java语言高级——常用类"><a href="#Java语言高级——常用类" class="headerlink" title="Java语言高级——常用类"></a>Java语言高级——常用类</h2><h3 id="字符串相关的类"><a href="#字符串相关的类" class="headerlink" title="字符串相关的类"></a>字符串相关的类</h3><p>String:字符串，使用一对””引起来表示。<br>    1.String声明为final的，不可被继承<br>    2.String实现了Serializable接口：表示字符串是支持序列化的。<br>            实现了Comparable接口：表示String可以比较大小<br>    3.String内部定义了final char[] value用于存储字符串数据<br>    4.String:代表不可变的字符序列。简称：不可变性。<br>        体现：1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。<br>             2. 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。<br>             3. 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。<br>    5.通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。<br>    6.字符串常量池中是不会存储相同内容的字符串的。</p>
<h3 id="啊"><a href="#啊" class="headerlink" title="啊"></a>啊</h3>]]></content>
      <categories>
        <category>Java高级</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据结构与算法——堆栈</title>
    <url>/2019/12/29/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%A0%86%E6%A0%88/</url>
    <content><![CDATA[<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191229/Tfa3DK90E3vf.jpg" alt="mark"></p>
<a id="more"></a>

<h1 id="Java数据结构与算法——堆栈"><a href="#Java数据结构与算法——堆栈" class="headerlink" title="Java数据结构与算法——堆栈"></a>Java数据结构与算法——堆栈</h1><h2 id="堆栈的应用场景和介绍"><a href="#堆栈的应用场景和介绍" class="headerlink" title="堆栈的应用场景和介绍"></a>堆栈的应用场景和介绍</h2><h3 id="堆栈基础"><a href="#堆栈基础" class="headerlink" title="堆栈基础"></a>堆栈基础</h3><ul>
<li>栈的英文为(stack)</li>
<li>栈是一个先入后出(FILO-First In Last Out)的有序列表。</li>
<li>栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。</li>
<li>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</li>
</ul>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191229/I76VT6KtrRP5.png" alt="mark"></p>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191229/OOFjkGvur7aL.png" alt="mark"></p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。  </li>
<li>处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。</li>
<li>表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。</li>
<li>二叉树的遍历。</li>
<li>图形的深度优先(depth一first)搜索法。</li>
</ul>
<h2 id="堆栈的实现"><a href="#堆栈的实现" class="headerlink" title="堆栈的实现"></a>堆栈的实现</h2><h3 id="数组实现堆栈"><a href="#数组实现堆栈" class="headerlink" title="数组实现堆栈"></a>数组实现堆栈</h3><p>知道了堆栈的性质后，我们可以使用数组来模拟堆栈，非常简单，不赘述。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">		arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 堆栈已满</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 堆栈为空</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 入栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"堆栈已满~~~"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		top++;</span><br><span class="line">		arr[top] = num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 出栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"堆栈为空~~~"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> temp = arr[top];</span><br><span class="line">		top--;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"堆栈为空~~~"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"arr[%d] = %d\n"</span>, i, arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="链表实现堆栈"><a href="#链表实现堆栈" class="headerlink" title="链表实现堆栈"></a>链表实现堆栈</h3><p>也可以用链表实现堆栈，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedListStack</span> </span>&#123;</span><br><span class="line">	LinkedNode first = <span class="keyword">new</span> LinkedNode(-<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> maxSize;</span><br><span class="line">	LinkedNode top;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LinkedListStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 取到链表长度</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">		LinkedNode temp = first;</span><br><span class="line">		<span class="keyword">while</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">			temp = temp.next;</span><br><span class="line">			length++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> length;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 取到特定节点的值。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		LinkedNode temp = first;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> temp.num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断堆栈是否为满</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> getLength() == maxSize;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断堆栈是否为空</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> first.next == <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 入栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表堆栈已满~~~~"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		LinkedNode newNode = <span class="keyword">new</span> LinkedNode(num);</span><br><span class="line">		LinkedNode temp = first;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		temp.next = newNode;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 出栈</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"链表堆栈为空~~~~"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		LinkedNode temp = first;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> value = temp.next.num;</span><br><span class="line">		temp.next = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"链表堆栈为空~~~~"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> length = getLength();</span><br><span class="line">		System.out.println(<span class="string">"链表堆栈长度为:"</span> + length);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = length; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"arr[%d] = %d\n"</span>, i, getNum(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> no;</span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	LinkedNode next;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LinkedNode</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.num = num;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="波兰计算器的实现"><a href="#波兰计算器的实现" class="headerlink" title="波兰计算器的实现"></a>波兰计算器的实现</h2><h3 id="中缀表达式计算器"><a href="#中缀表达式计算器" class="headerlink" title="中缀表达式计算器"></a>中缀表达式计算器</h3><p>中缀表达式的计算相对比较复杂，具体步骤是：</p>
<ul>
<li><p>分别建立一个数据栈numStack和操作符栈operStack；</p>
</li>
<li><p>遍历表达式，如果是数字就直接入栈（多位数的处理需要注意）；</p>
</li>
<li><p>如果是操作符：</p>
<ul>
<li><p>首先判断operStack是否为空，如果为空，直接将操作符入栈；</p>
</li>
<li><p>如果操作符不为空，判断operStack栈顶操作符和该操作符的优先级</p>
<ul>
<li><p>如果该操作符优先级高于operStack栈顶操作符，直接入栈</p>
</li>
<li><p>如果该操作符优先级低于operStack栈顶操作符，弹出numStack和operStack栈顶操作符，进行计算，将结果加入numStack。再将该操作符入栈。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行；</p>
</li>
<li><p>最后在数栈只有一个数字，就是表达式的结果。</p>
</li>
</ul>
<p><strong>【注意】本操作没有考虑有括号的中缀表达式的处理方法！！！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	String expression = <span class="string">"117*2*112-5+1-5+3-4"</span>; <span class="comment">// 18//如何处理多位数的问题？</span></span><br><span class="line">	ArrayStack2 numStack = <span class="keyword">new</span> ArrayStack2(<span class="number">10</span>);</span><br><span class="line">	ArrayStack2 operStack = <span class="keyword">new</span> ArrayStack2(<span class="number">10</span>);</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> oper = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> ch = <span class="string">' '</span>;</span><br><span class="line">	String num = <span class="string">""</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		ch = expression.substring(index, index + <span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line">		<span class="comment">// 判断是否为符号</span></span><br><span class="line">		<span class="keyword">if</span> (operStack.isOper(ch)) &#123;</span><br><span class="line">			<span class="comment">// 符号操作</span></span><br><span class="line">			<span class="comment">// 如果发现当前的符号栈为 空，就直接入栈</span></span><br><span class="line">			<span class="keyword">if</span> (operStack.isEmpty()) &#123;</span><br><span class="line">				operStack.push(ch);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;	</span><br><span class="line">           <span class="comment">// 如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符</span></span><br><span class="line">		<span class="keyword">if</span> (operStack.priority(ch) &lt;= operStack.priority(operStack.peek())) &#123;</span><br><span class="line">			<span class="comment">// 就需要从数栈中pop出两个数,在从符号栈中pop出一个符号，</span></span><br><span class="line">			<span class="comment">// 进行运算，将得到结果，入数栈</span></span><br><span class="line">			<span class="comment">// 然后将当前的操作符入符号栈，</span></span><br><span class="line">				num1 = numStack.pop();</span><br><span class="line">				num2 = numStack.pop();</span><br><span class="line">				oper = operStack.pop();</span><br><span class="line">				res = operStack.cal(num1, num2, oper);</span><br><span class="line">				numStack.push(res);</span><br><span class="line">				operStack.push(ch);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;			<span class="comment">// 如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.</span></span><br><span class="line">				operStack.push(ch);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果我们发现是一个数字, 就直接入数栈</span></span><br><span class="line">			<span class="comment">// numStack.push(ch - 48);</span></span><br><span class="line">			<span class="comment">// 判断是否为多位数</span></span><br><span class="line">			num = num + ch;</span><br><span class="line">			<span class="keyword">if</span> (index == expression.length() - <span class="number">1</span>) &#123;</span><br><span class="line">				numStack.push(Integer.parseInt(num));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (operStack.isOper(expression.substring(index + <span class="number">1</span>, index + <span class="number">2</span>).charAt(<span class="number">0</span>))) &#123;</span><br><span class="line">			numStack.push(Integer.parseInt(num));</span><br><span class="line">			num = <span class="string">""</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (index == expression.length() - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		index++;</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="comment">// 当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行.</span></span><br><span class="line">		<span class="comment">// 最后在数栈只有一个数字，就是表达式的结果</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (operStack.isEmpty()) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			num1 = numStack.pop();</span><br><span class="line">			num2 = numStack.pop();</span><br><span class="line">			oper = operStack.pop();</span><br><span class="line">			res = operStack.cal(num1, num2, oper);</span><br><span class="line">			numStack.push(res);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> res2 = numStack.pop();</span><br><span class="line">		System.out.printf(<span class="string">"表达式 %s = %d"</span>, expression, res2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="后缀表达式计算器"><a href="#后缀表达式计算器" class="headerlink" title="后缀表达式计算器"></a>后缀表达式计算器</h3><p>后缀表达式利用堆栈计算非常有效，基本的做法是：</p>
<ul>
<li><p>从左到右遍历，遇到数字压入堆栈。</p>
</li>
<li><p>遇到运算符，弹出堆栈顶上两个数据，进行运算，再将运算后的结果入栈。</p>
<ul>
<li>对于”+“和”*“，直接处理。</li>
<li>对于”-“和”/“，需要注意的是，栈顶元素是被操作数，次栈顶元素是操作数，也就是说应该是次栈顶元素-栈顶元素，或次栈顶元素/栈顶元素。</li>
</ul>
</li>
<li><p>最后留在栈内的是最终计算结果。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完成对逆波兰表达式的运算</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 1)从左至右扫描，将3和4压入堆栈； </span></span><br><span class="line"><span class="comment">	 * 2)遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈； </span></span><br><span class="line"><span class="comment">	 * 3)将5入栈；</span></span><br><span class="line"><span class="comment">	 * 4)接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈； </span></span><br><span class="line"><span class="comment">	 * 5)将6入栈； </span></span><br><span class="line"><span class="comment">	 * 6)最后是-运算符，计算出35-6的值，即29，由此得出最终结果</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line">		Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">		<span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> num2 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ls.size(); i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ls.get(i).matches(<span class="string">"\\d+"</span>)) &#123;</span><br><span class="line">				stack.push(ls.get(i));</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				num1 = Integer.parseInt(stack.pop());</span><br><span class="line">				num2 = Integer.parseInt(stack.pop());</span><br><span class="line">				<span class="keyword">switch</span> (ls.get(i)) &#123;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">					res = num1 + num2;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">					res = num2 - num1;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">					res = num1 * num2;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">					res = num2 / num1;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				stack.push(<span class="string">""</span> + res);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h3 id="中缀转后缀表达式"><a href="#中缀转后缀表达式" class="headerlink" title="中缀转后缀表达式"></a>中缀转后缀表达式</h3><p>基本步骤：</p>
<ul>
<li><p>从左到右进行遍历。</p>
</li>
<li><p>运算数,直接输出。</p>
</li>
<li><p>左括号,直接压入堆栈,(括号是最高优先级,无需比较)(入栈后优先级降到最低,确保其他符号正常入栈)。</p>
</li>
<li><p>右括号,(意味着括号已结束)不断弹出栈顶运算符并输出直到遇到左括号(弹出但不输出)。</p>
</li>
<li><p>运算符,将该运算符与栈顶运算符进行比较。</p>
<ul>
<li><p>如果优先级高于栈顶运算符则压入堆栈(该部分运算还不能进行)。</p>
</li>
<li><p>如果优先级低于等于栈顶运算符则将栈顶运算符弹出并输出,然后比较新的栈顶运算符。(低于弹出意味着前面部分可以运算,先输出的一定是高优先级运算符,等于弹出是因为同等优先级,从左到右运算)<br>直到优先级大于栈顶运算符或者栈空,再将该运算符入栈.</p>
</li>
</ul>
</li>
<li><p>如果对象处理完毕,则按顺序弹出并输出栈中所有运算符。</p>
</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,–]</span></span><br><span class="line">	<span class="comment">// 方法：将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">parseSuffixExpreesionList</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 1.从左到右进行遍历 </span></span><br><span class="line"><span class="comment">		 * 2.运算数,直接输出. </span></span><br><span class="line"><span class="comment">		 * 3.左括号,直接压入堆栈,(括号是最高优先级,无需比较)(入栈后优先级降到最低,确保其他符号正常入栈)</span></span><br><span class="line"><span class="comment">		 * 4.右括号,(意味着括号已结束)不断弹出栈顶运算符并输出直到遇到左括号(弹出但不输出)</span></span><br><span class="line"><span class="comment">		 * 5.运算符,将该运算符与栈顶运算符进行比较,</span></span><br><span class="line"><span class="comment">		 * 如果优先级高于栈顶运算符则压入堆栈(该部分运算还不能进行), </span></span><br><span class="line"><span class="comment">		 * 如果优先级低于等于栈顶运算符则将栈顶运算符弹出并输出,然后比较新的栈顶运算符.</span></span><br><span class="line"><span class="comment">		 *(低于弹出意味着前面部分可以运算,</span></span><br><span class="line"><span class="comment">		 * 先输出的一定是高优先级运算符,等于弹出是因为同等优先级,从左到右运算)</span></span><br><span class="line"><span class="comment">		 * 直到优先级大于栈顶运算符或者栈空,再将该运算符入栈. </span></span><br><span class="line"><span class="comment">		 *6.如果对象处理完毕,则按顺序弹出并输出栈中所有运算符.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Stack&lt;String&gt; s1 = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line">		List&lt;String&gt; s2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">		<span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">			<span class="keyword">if</span> (item.matches(<span class="string">"\\d+"</span>)) &#123;</span><br><span class="line">				s2.add(item);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"("</span>)) &#123;</span><br><span class="line">				s1.push(item);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">")"</span>)) &#123;</span><br><span class="line">				<span class="keyword">while</span>(!s1.peek().equals(<span class="string">"("</span>)) &#123;</span><br><span class="line">					s2.add(s1.pop());</span><br><span class="line">				&#125;</span><br><span class="line">				s1.pop();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">while</span>(s1.size() &gt; <span class="number">0</span> &amp;&amp; Operation.getValue(item) &lt;= Operation.getValue(s1.peek())) &#123;</span><br><span class="line">					s2.add(s1.pop());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 还需要将item压入栈</span></span><br><span class="line">				s1.push(item);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (s1.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			s2.add(s1.pop());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s2;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java语言高级——多线程</title>
    <url>/2019/12/26/Java%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191226/gqJ6FCLtTzbj.jpg" alt="mark"></p>
<a id="more"></a>

<h2 id="线程的创建和使用"><a href="#线程的创建和使用" class="headerlink" title="线程的创建和使用"></a>线程的创建和使用</h2><h3 id="线程创建方式一：继承Thread类"><a href="#线程创建方式一：继承Thread类" class="headerlink" title="线程创建方式一：继承Thread类"></a>线程创建方式一：继承Thread类</h3><ol>
<li>创建一个继承于Thread类的子类</li>
<li>重写Thread类的run() –&gt; 将此线程执行的操作声明在run()中</li>
<li>创建Thread类的子类的对象</li>
<li>通过此对象调用start()</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 创建一个继承于Thread类的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2. 重写Thread类的run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3. 创建Thread类的子类的对象</span></span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.通过此对象调用start():①启动当前线程 ② 调用当前线程的run()</span></span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//问题一：我们不能通过直接调用run()的方式启动线程。</span></span><br><span class="line"><span class="comment">//        t1.run();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//问题二：再启动一个线程，遍历100以内的偶数。不可以还让已经start()的线程去执行。会报IllegalThreadStateException</span></span><br><span class="line"><span class="comment">//        t1.start();</span></span><br><span class="line">        <span class="comment">//我们需要重新创建一个线程的对象</span></span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如下操作仍然是在main线程中执行的。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i + <span class="string">"***********main()************"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Thread类的有关方法</strong></p>
<blockquote>
<ul>
<li><p>void start(): 启动线程，并执行对象的run()方法</p>
</li>
<li><p>run(): 线程在被调度时执行的操作</p>
</li>
<li><p>String getName(): 返回线程的名称</p>
</li>
<li><p>void setName(String name):设置该线程名称</p>
</li>
<li><p>static Thread currentThread(): 返回当前线程。在Thread子类中就<br>是this，通常用于主线程和Runnable实现类</p>
</li>
<li><p>static void yield()：线程让步 </p>
<ul>
<li><p>暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线</p>
</li>
<li><p>若队列中没有同优先级的线程，忽略此方法</p>
</li>
</ul>
</li>
<li><p>join() ：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将 被阻塞，直到 join() 方法加入的 join 线程执行完为止 </p>
</li>
<li><p>低优先级的线程也可以获得执行 </p>
</li>
<li><p>static void sleep(long millis)：(指定时间:毫秒)</p>
<ul>
<li>令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后 重排队。<ul>
<li>抛出InterruptedException异常 </li>
</ul>
</li>
</ul>
</li>
<li><p>stop(): 强制线程生命期结束，不推荐使用</p>
</li>
<li><p>boolean isAlive()：返回boolean，判断线程是否还活着</p>
</li>
</ul>
</blockquote>
<h3 id="线程创建方式二：实现Runnable接口"><a href="#线程创建方式二：实现Runnable接口" class="headerlink" title="线程创建方式二：实现Runnable接口"></a>线程创建方式二：实现Runnable接口</h3><ol>
<li>创建一个实现了Runnable接口的类</li>
<li>实现类去实现Runnable中的抽象方法：run()</li>
<li>创建实现类的对象</li>
<li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li>
<li>通过Thread类的对象调用start()</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 创建一个实现了Runnable接口的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 实现类去实现Runnable中的抽象方法：run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3. 创建实现类的对象</span></span><br><span class="line">        MThread mThread = <span class="keyword">new</span> MThread();</span><br><span class="line">        <span class="comment">//4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(mThread);</span><br><span class="line">        t1.setName(<span class="string">"线程1"</span>);</span><br><span class="line">        <span class="comment">//5. 通过Thread类的对象调用start():① 启动线程 ②调用当前线程的run()--&gt;调用了Runnable类型的target的run()</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再启动一个线程，遍历100以内的偶数</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(mThread);</span><br><span class="line">        t2.setName(<span class="string">"线程2"</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="比较创建线程的两种方式"><a href="#比较创建线程的两种方式" class="headerlink" title="比较创建线程的两种方式"></a>比较创建线程的两种方式</h3><p>开发中：优先选择：实现Runnable接口的方式</p>
<p>原因：</p>
<ul>
<li><p>实现的方式没有类的单继承性的局限性</p>
</li>
<li><p>实现的方式更适合来处理多个线程有共享数据的情况</p>
</li>
</ul>
<p>联系：public class Thread implements Runnable</p>
<p>相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。</p>
<h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态：</p>
<ul>
<li><p>新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</p>
</li>
<li><p>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源</p>
</li>
<li><p>运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能</p>
</li>
<li><p>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态</p>
</li>
<li><p>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</p>
</li>
</ul>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191230/yJ6pfSu9PM1C.png" alt="mark"></p>
<h2 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h2><p>在Java中，我们通过同步机制，来解决线程的安全问题。</p>
<h3 id="方式一：同步代码块"><a href="#方式一：同步代码块" class="headerlink" title="方式一：同步代码块"></a>方式一：同步代码块</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line">    <span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li><p>操作共享数据的代码，即为需要被同步的代码。  –&gt;不能包含代码多了，也不能包含代码少了。</p>
</li>
<li><p>共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。</p>
</li>
<li><p>同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。</p>
<p>要求：多个线程必须要共用同一把锁。</p>
</li>
</ol>
<p>补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。</p>
<h3 id="方式二：同步方法"><a href="#方式二：同步方法" class="headerlink" title="方式二：同步方法"></a>方式二：同步方法</h3><p>如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。</p>
<p>同步的方式，解决了线程的安全问题。—好处</p>
<p>操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 —局限性</p>
<p>关于同步方法的总结：</p>
<ul>
<li>同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。</li>
<li>非静态的同步方法，同步监视器是：this</li>
<li>静态的同步方法，同步监视器是：当前类本身</li>
</ul>
<h3 id="线程的死锁问题"><a href="#线程的死锁问题" class="headerlink" title="线程的死锁问题"></a>线程的死锁问题</h3><ul>
<li>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃 自己需要的同步资源，就形成了线程的死锁 </li>
<li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于 阻塞状态，无法继续</li>
</ul>
<p>解决方法：</p>
<ul>
<li>专门的算法、原则</li>
<li>尽量减少同步资源的定义 </li>
<li>尽量避免嵌套同步</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决线程安全问题的方式三：Lock锁  --- JDK5.0新增</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 面试题：synchronized 与 Lock的异同？</span></span><br><span class="line"><span class="comment"> *   相同：二者都可以解决线程安全问题</span></span><br><span class="line"><span class="comment"> *   不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器</span></span><br><span class="line"><span class="comment"> *        Lock需要手动的启动同步（lock()），同时结束同步也需要手动的实现（unlock()）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.优先使用顺序：</span></span><br><span class="line"><span class="comment"> * Lock  同步代码块（已经进入了方法体，分配了相应资源）  同步方法（在方法体之外）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  面试题：如何解决线程安全问题？有几种方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-02-15 下午 3:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//1.实例化ReentrantLock</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//2.调用锁定方法lock()</span></span><br><span class="line">                lock.lock();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">"：售票，票号为："</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//3.调用解锁方法：unlock()</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Window w = <span class="keyword">new</span> Window();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(w);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">"窗口1"</span>);</span><br><span class="line">        t2.setName(<span class="string">"窗口2"</span>);</span><br><span class="line">        t3.setName(<span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Lock-锁"><a href="#Lock-锁" class="headerlink" title="Lock(锁)"></a>Lock(锁)</h3><ul>
<li>从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同 步锁对象来实现同步。同步锁使用Lock对象充当。 </li>
<li>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的 工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象 加锁，线程开始访问共享资源之前应先获得Lock对象。 </li>
<li>ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和 内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以 显式加锁、释放锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReenTrantLock();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="comment">//保证线程安全的代码;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span>&#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>synchronized 与 Lock 的对比</strong> </p>
<ol>
<li><p>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是 隐式锁，出了作用域自动释放 </p>
</li>
<li><p>Lock只有代码块锁，synchronized有代码块锁和方法锁 </p>
</li>
<li><p>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有 更好的扩展性（提供更多的子类）</p>
</li>
</ol>
<p><strong>优先使用顺序</strong></p>
<p>Lock —&gt;同步代码块（已经进入了方法体，分配了相应资源）—&gt;同步方法 （在方法体之外）</p>
<h2 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h2><ul>
<li>wait() 与 notify() 和 notifyAll() <ul>
<li>wait()：令当前线程挂起并放弃CPU、同步资源并等待，使别的线程可访问并修改共享资源，而当 前线程排队等候其他线程调用notify()或notifyAll()方法唤醒，唤醒后等待重新获得对监视器的所有 权后才能继续执行。</li>
<li>notify()：唤醒正在排队等待同步资源的线程中优先级最高者结束等待。</li>
<li>notifyAll ()：唤醒正在排队等待资源的所有线程结束等待。</li>
</ul>
</li>
<li>这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报 java.lang.IllegalMonitorStateException异常。 </li>
<li>因为这三个方法必须有锁对象调用，而任意对象都可以作为synchronized的同步锁， 因此这三个方法只能在Object类中声明。</li>
</ul>
<h3 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait() 方法"></a>wait() 方法</h3><ul>
<li>在当前线程中调用方法： 对象名.wait() 使当前线程进入等待（某对象）状态 ，直到另一线程对该对象发出 notify (或notifyAll) 为止。 </li>
<li>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁） 调用此方法后，当前线程将释放对象监控权 ，然后进入等待 </li>
<li>在当前线程被notify后，要重新获得监控权，然后从断点处继续代码的执行。</li>
</ul>
<h3 id="notify-notifyAll"><a href="#notify-notifyAll" class="headerlink" title="notify()/notifyAll()"></a>notify()/notifyAll()</h3><ul>
<li>在当前线程中调用方法： 对象名.notify() </li>
<li>功能：唤醒等待该对象监控权的一个/所有线程。 </li>
<li>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）</li>
</ul>
<h3 id="经典例题：生产者-消费者问题"><a href="#经典例题：生产者-消费者问题" class="headerlink" title="经典例题：生产者/消费者问题"></a>经典例题：生产者/消费者问题</h3><ul>
<li>生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处 取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图 生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通 知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如 果店中有产品了再通知消费者来取走产品。 </li>
<li>这里可能出现两个问题： <ul>
<li>生产者比消费者快时，消费者会漏掉一些数据没有取到。 </li>
<li>消费者比生产者快时，消费者会取相同的数据。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.java2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程通信的应用：经典例题：生产者/消费者问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，</span></span><br><span class="line"><span class="comment"> * 店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员</span></span><br><span class="line"><span class="comment"> * 会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品</span></span><br><span class="line"><span class="comment"> * 了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 分析：</span></span><br><span class="line"><span class="comment"> * 1. 是否是多线程问题？是，生产者线程，消费者线程</span></span><br><span class="line"><span class="comment"> * 2. 是否有共享数据？是，店员（或产品）</span></span><br><span class="line"><span class="comment"> * 3. 如何解决线程的安全问题？同步机制,有三种方法</span></span><br><span class="line"><span class="comment"> * 4. 是否涉及线程的通信？是</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-02-15 下午 4:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clerk</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> productCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//生产产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produceProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(productCount &lt; <span class="number">20</span>)&#123;</span><br><span class="line">            productCount++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":开始生产第"</span> + productCount + <span class="string">"个产品"</span>);</span><br><span class="line"></span><br><span class="line">            notify();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//消费产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consumeProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(productCount &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":开始消费第"</span> + productCount + <span class="string">"个产品"</span>);</span><br><span class="line">            productCount--;</span><br><span class="line"></span><br><span class="line">            notify();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;<span class="comment">//生产者</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">":开始生产产品....."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clerk.produceProduct();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;<span class="comment">//消费者</span></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">":开始消费产品....."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            clerk.consumeProduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Clerk clerk = <span class="keyword">new</span> Clerk();</span><br><span class="line"></span><br><span class="line">        Producer p1 = <span class="keyword">new</span> Producer(clerk);</span><br><span class="line">        p1.setName(<span class="string">"生产者1"</span>);</span><br><span class="line"></span><br><span class="line">        Consumer c1 = <span class="keyword">new</span> Consumer(clerk);</span><br><span class="line">        c1.setName(<span class="string">"消费者1"</span>);</span><br><span class="line">        Consumer c2 = <span class="keyword">new</span> Consumer(clerk);</span><br><span class="line">        c2.setName(<span class="string">"消费者2"</span>);</span><br><span class="line"></span><br><span class="line">        p1.start();</span><br><span class="line">        c1.start();</span><br><span class="line">        c2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="JDK5-0-新增线程创建方式"><a href="#JDK5-0-新增线程创建方式" class="headerlink" title="JDK5.0 新增线程创建方式"></a>JDK5.0 新增线程创建方式</h2><h3 id="新增方式一：实现Callable接口"><a href="#新增方式一：实现Callable接口" class="headerlink" title="新增方式一：实现Callable接口"></a>新增方式一：实现Callable接口</h3><p><strong>Future接口</strong> </p>
<ul>
<li>可以对具体Runnable、Callable任务的执行结果进行取消、查询是 否完成、获取结果等。 </li>
<li>FutrueTask是Futrue接口的唯一的实现类 </li>
<li>FutureTask 同时实现了Runnable, Future接口。它既可以作为 Runnable被线程执行，又可以作为Future得到Callable的返回值</li>
</ul>
<h3 id="新增方式二：使用线程池"><a href="#新增方式二：使用线程池" class="headerlink" title="新增方式二：使用线程池"></a>新增方式二：使用线程池</h3><p><strong>背景：</strong>经常创建和销毁、使用量特别大的资源，比如并发情况下的线程， 对性能影响很大。 </p>
<p><strong>思路：</strong>提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交 通工具。 </p>
<p><strong>好处：</strong> </p>
<ul>
<li>提高响应速度（减少了创建新线程的时间） </li>
<li>降低资源消耗（重复利用线程池中线程，不需要每次都创建） </li>
<li>便于线程管理</li>
</ul>
]]></content>
      <categories>
        <category>Java高级</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识——异常处理</title>
    <url>/2019/12/24/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191224/cKrbT5eichum.jpg" alt="mark"></p>
<a id="more"></a>

<h2 id="Java基础知识——异常处理"><a href="#Java基础知识——异常处理" class="headerlink" title="Java基础知识——异常处理"></a>Java基础知识——异常处理</h2><h3 id="1-异常概述与异常体系结构"><a href="#1-异常概述与异常体系结构" class="headerlink" title="1. 异常概述与异常体系结构"></a>1. 异常概述与异常体系结构</h3><ul>
<li><p>异常：在Java语言中，将程序执行中发生的不正常情况称为“异常” 。 (开发过程中的语法错误和逻辑错误不是异常)</p>
</li>
<li><p>Java程序在执行过程中所发生的异常事件可分为两类：</p>
<ul>
<li><p>Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源 耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性 的代码进行处理。</p>
</li>
<li><p>Exception: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使 用针对性的代码进行处理。例如：</p>
<p><strong>空指针访问</strong> </p>
<p><strong>试图读取不存在的文件</strong> </p>
<p><strong>网络连接中断</strong></p>
<p><strong>数组角标越界</strong></p>
</li>
</ul>
</li>
</ul>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191224/bLT684OP0eJG.png" alt="mark"><br><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191224/Y3gdDx15hqaP.png" alt="mark"></p>
<h3 id="2-常见异常"><a href="#2-常见异常" class="headerlink" title="2. 常见异常"></a>2. 常见异常</h3><h3 id="3-异常处理机制一：try–catch–finally"><a href="#3-异常处理机制一：try–catch–finally" class="headerlink" title="3. 异常处理机制一：try–catch–finally"></a>3. 异常处理机制一：try–catch–finally</h3><h4 id="异常的处理：抓抛模型"><a href="#异常的处理：抓抛模型" class="headerlink" title="异常的处理：抓抛模型"></a>异常的处理：抓抛模型</h4><ul>
<li><p>过程一：”抛”：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。并将此对象抛出。一旦抛出对象以后，其后的代码就不再执行。</p>
<p>关于异常对象的产生：</p>
<p>① 系统自动生成的异常对象</p>
<p>② 手动的生成一个异常对象，并抛出（throw）</p>
</li>
<li><p>过程二：”抓”：可以理解为异常的处理方式：① try-catch-finally  ② throws</p>
</li>
</ul>
<h4 id="try-catch-finally的使用"><a href="#try-catch-finally的使用" class="headerlink" title="try-catch-finally的使用"></a>try-catch-finally的使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"> 		<span class="comment">//可能出现异常的代码</span></span><br><span class="line"> </span><br><span class="line"> &#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line"> 		<span class="comment">//处理异常的方式1</span></span><br><span class="line"> &#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line"> 		<span class="comment">//处理异常的方式2</span></span><br><span class="line"> &#125;<span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>)&#123;</span><br><span class="line"> 		<span class="comment">//处理异常的方式3</span></span><br><span class="line"> &#125;</span><br><span class="line"> ....</span><br><span class="line"> <span class="keyword">finally</span>&#123;</span><br><span class="line"> 		<span class="comment">//一定会执行的代码</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li><p>finally是可选的。</p>
</li>
<li><p>使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象</p>
</li>
</ol>
<p>的类型，去catch中进行匹配</p>
<ol start="3">
<li>一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的</li>
</ol>
<p>try-catch结构（在没有写finally的情况）。继续执行其后的代码</p>
<ol start="4">
<li>catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓。</li>
</ol>
<p>catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错</p>
<ol start="5">
<li><p>常用的异常对象处理的方式： ① String  getMessage()    ② printStackTrace()</p>
</li>
<li><p>在try结构中声明的变量，再出了try结构以后，就不能再被调用</p>
</li>
<li><p>try-catch-finally结构可以嵌套</p>
</li>
</ol>
<p>体会1：使用try-catch-finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。</p>
<p>体会2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。针对于编译时异常，我们说一定要考虑异常的处理。</p>
<h4 id="try-catch-finally中finally的使用："><a href="#try-catch-finally中finally的使用：" class="headerlink" title="try-catch-finally中finally的使用："></a>try-catch-finally中finally的使用：</h4><ol>
<li><p>finally是可选的</p>
</li>
<li><p>finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中有return语句，catch中有return语句等情况。</p>
</li>
<li><p>像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。</p>
</li>
</ol>
<h3 id="4-异常处理机制二：throws"><a href="#4-异常处理机制二：throws" class="headerlink" title="4. 异常处理机制二：throws"></a>4. 异常处理机制二：throws</h3><ol>
<li><p>“throws + 异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！</p>
</li>
<li><p>体会：try-catch-finally:真正的将异常给处理掉了。throws的方式只是将异常抛给了方法的调用者。  并没有真正将异常处理掉。  </p>
</li>
<li><p>开发中如何选择使用try-catch-finally 还是使用throws？</p>
</li>
</ol>
<ul>
<li><p>如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理。</p>
</li>
<li><p>执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。</p>
</li>
</ul>
<h3 id="5-手动抛出异常：throw"><a href="#5-手动抛出异常：throw" class="headerlink" title="5. 手动抛出异常：throw"></a>5. 手动抛出异常：throw</h3><p>Java异常类对象除在程序执行过程中出现异常时由系统自动生成并 抛出，也可根据需要使用人工创建并抛出。 </p>
<ul>
<li><p>首先要生成异常类对象，然后通过throw语句实现抛出操作(提交给Java运 行环境)。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IOException e = <span class="keyword">new</span> IOException(); </span><br><span class="line"><span class="keyword">throw</span> e;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以抛出的异常必须是Throwable或其子类的实例。下面的语句在编译时将 会产生语法错误： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> String(<span class="string">"want to throw"</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="6-用户自定义异常"><a href="#6-用户自定义异常" class="headerlink" title="6. 用户自定义异常"></a>6. 用户自定义异常</h3><p>如何自定义异常类？</p>
<ul>
<li>继承于现有的异常结构：RuntimeException 、Exception</li>
<li>提供全局常量：serialVersionUID</li>
<li>提供重载的构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EcDef</span>  <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">33875164229948L</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">EcDef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">EcDef</span> <span class="params">(String message)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(message);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识——抽象和接口</title>
    <url>/2019/12/21/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p><img src="http://image.gwbiubiubiu.com/blog/20191221/DAppFmUfqzKl.jpg" alt="mark"></p>
<a id="more"></a>

<h1 id="Java基础知识——抽象和接口"><a href="#Java基础知识——抽象和接口" class="headerlink" title="Java基础知识——抽象和接口"></a>Java基础知识——抽象和接口</h1><h2 id="抽象：abstract"><a href="#抽象：abstract" class="headerlink" title="抽象：abstract"></a>抽象：abstract</h2><h3 id="abstract关键字的使用"><a href="#abstract关键字的使用" class="headerlink" title="abstract关键字的使用"></a>abstract关键字的使用</h3><ol>
<li>abstract:抽象的</li>
</ol>
<ol start="2">
<li>abstract可以用来修饰的结构：类、方法</li>
</ol>
<ol start="3">
<li>abstract修饰类：抽象类</li>
</ol>
<blockquote>
<p>此类不能实例化</p>
<p>抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）</p>
<p>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作</p>
</blockquote>
<ol start="4">
<li>abstract修饰方法：抽象方法</li>
</ol>
<blockquote>
<p>抽象方法只有方法的声明，没有方法体</p>
<p>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。</p>
<p>若子类重写了父类中的所有的抽象方法后，此子类方可实例化</p>
</blockquote>
<p>若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</p>
<h3 id="abstract使用上的注意点"><a href="#abstract使用上的注意点" class="headerlink" title="abstract使用上的注意点"></a>abstract使用上的注意点</h3><p>abstract不能用来修饰：属性、构造器等结构</p>
<p>abstract不能用来修饰私有方法、静态方法、final的方法、final的类</p>
<h2 id="接口：interface"><a href="#接口：interface" class="headerlink" title="接口：interface"></a>接口：interface</h2><p>接口的使用</p>
<p>1.接口使用interface来定义</p>
<p>2.Java中，接口和类是并列的两个结构</p>
<p>3.如何定义接口：定义接口中的成员</p>
<ul>
<li>JDK7及以前：只能定义全局常量和抽象方法</li>
</ul>
<blockquote>
<p>全局常量：public static final的.但是书写时，可以省略不写</p>
<p>抽象方法：public abstract的</p>
</blockquote>
<ul>
<li>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</li>
</ul>
<blockquote>
<p>知识点1：接口中定义的静态方法，只能通过接口来调用。</p>
<p>知识点2：通过实现类的对象，可以调用接口中的默认方法。</p>
<p>如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法<br>知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，</p>
<p>那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。–&gt;类优先原则</p>
<p>知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，</p>
<p>那么在实现类没有重写此方法的情况下，报错。–&gt;接口冲突。</p>
<p>这就需要我们必须在实现类中重写此方法</p>
</blockquote>
<ol start="4">
<li><p>接口中不能定义构造器的！意味着接口不可以实例化</p>
</li>
<li><p>Java开发中，接口通过让类去实现(implements)的方式来使用.</p>
</li>
</ol>
<blockquote>
<p>如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化</p>
<p>如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类</p>
</blockquote>
<ol start="6">
<li>Java类可以实现多个接口   —&gt;弥补了Java单继承性的局限性</li>
</ol>
<blockquote>
<p>格式：class AA extends BB implements CC,DD,EE</p>
</blockquote>
<ol start="7">
<li><p>接口与接口之间可以继承，而且可以多继承</p>
</li>
<li><p>接口的具体使用，体现多态性</p>
</li>
<li><p>接口，实际上可以看做是一种规范</p>
</li>
</ol>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ol>
<li><p>Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类</p>
</li>
<li><p>内部类的分类：成员内部类（静态、非静态）  vs 局部内部类(方法内、代码块内、构造器内)</p>
</li>
<li><p>成员内部类：</p>
</li>
</ol>
<ul>
<li>一方面，作为外部类的成员：</li>
</ul>
<blockquote>
<p>调用外部类的结构</p>
<p>可以被static修饰</p>
<p>可以被4种不同的权限修饰</p>
</blockquote>
<ul>
<li>另一方面，作为一个类：</li>
</ul>
<blockquote>
<p>类内可以定义属性、方法、构造器等</p>
<p>可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承</p>
<p>可以被abstract修饰</p>
</blockquote>
<ol start="4">
<li>关注如下的3个问题</li>
</ol>
<ul>
<li><p>如何实例化成员内部类的对象</p>
</li>
<li><p>如何在成员内部类中区分调用外部类的结构</p>
</li>
<li><p>开发中局部内部类的使用  见《InnerClassTest1.java》</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest1</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//开发中很少见</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//局部内部类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//返回一个实现了Comparable接口的类的对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Comparable <span class="title">getComparable</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建一个实现了Comparable接口的类:局部内部类</span></span><br><span class="line">		<span class="comment">//方式一：</span></span><br><span class="line"><span class="comment">//		class MyComparable implements Comparable&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//			@Override</span></span><br><span class="line"><span class="comment">//			public int compareTo(Object o) &#123;</span></span><br><span class="line"><span class="comment">//				return 0;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//			</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		return new MyComparable();</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//方式二：</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Comparable()&#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据结构与算法——约瑟夫问题</title>
    <url>/2019/12/20/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191220/rW7Lvs3umTPq.jpg" alt="mark"></p>
<a id="more"></a>

<h2 id="Java数据结构与算法——约瑟夫问题"><a href="#Java数据结构与算法——约瑟夫问题" class="headerlink" title="Java数据结构与算法——约瑟夫问题"></a>Java数据结构与算法——约瑟夫问题</h2><p>Josephu 问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k (1&lt;=k&lt;=n)的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p>
<h4 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h4><p>用一个不带头结点的循环链表来处理Josephu 问题：先构成一个有n个结点的单循环链表，然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。</p>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191220/lMP5UPoTwgn6.png" alt="mark"></p>
<h4 id="构建一个单向的环形链表思路"><a href="#构建一个单向的环形链表思路" class="headerlink" title="构建一个单向的环形链表思路"></a>构建一个单向的环形链表思路</h4><p>先创建第一个节点, 让 first 指向该节点，并形成环形，后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表中即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加小孩节点，构建成一个环形的链表</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBoy</span><span class="params">(<span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (nums &lt; <span class="number">1</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"nums的值不正确"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Boy curBoy = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line">			Boy newBoy = <span class="keyword">new</span> Boy(i);</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">				first = newBoy;</span><br><span class="line">				first.setNext(first);</span><br><span class="line">				curBoy = first;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				curBoy.setNext(newBoy);</span><br><span class="line">				newBoy.setNext(first);</span><br><span class="line">				curBoy = curBoy.getNext();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h4 id="遍历环形链表"><a href="#遍历环形链表" class="headerlink" title="遍历环形链表"></a>遍历环形链表</h4><p>先让一个辅助指针(变量) curBoy，指向first节点，然后通过一个while循环遍历 该环形链表即可 curBoy.next == first 结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历当前的环形链表</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBoy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断链表是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"没有任何小孩~~"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 因为first不能动，因此我们仍然使用一个辅助指针完成遍历</span></span><br><span class="line">		Boy curBoy = first;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"小孩的编号 %d \n"</span>, curBoy.getNo());</span><br><span class="line">			<span class="keyword">if</span> (curBoy.getNext() == first) &#123;<span class="comment">// 说明已经遍历完毕</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			curBoy = curBoy.getNext(); <span class="comment">// curBoy后移</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h4 id="根据用户的输入，生成一个小孩出圈的顺序"><a href="#根据用户的输入，生成一个小孩出圈的顺序" class="headerlink" title="根据用户的输入，生成一个小孩出圈的顺序"></a>根据用户的输入，生成一个小孩出圈的顺序</h4><ul>
<li><p>n = 5 , 即有5个人</p>
</li>
<li><p>k = 1, 从第一个人开始报数</p>
</li>
<li><p>m = 2, 数2下</p>
</li>
</ul>
<p>需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点.</p>
<p>补充： 小孩报数前，先让 first 和 helper 移动 k - 1次</p>
<p>当小孩报数时，让first 和 helper 指针同时 的移动 m - 1 次</p>
<p>这时就可以将first 指向的小孩节点 出圈</p>
<p>first = first .next </p>
<p>helper.next = first </p>
<p>原来first 指向的节点就没有任何引用，就会被回收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据用户的输入，计算出小孩出圈的顺序</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> startNo  表示从第几个小孩开始数数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> countNum 表示数几下</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> nums     表示最初有多少小孩在圈中</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countBoy</span><span class="params">(<span class="keyword">int</span> startNo, <span class="keyword">int</span> countNum, <span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 先对数据进行校验</span></span><br><span class="line">		<span class="keyword">if</span> (first == <span class="keyword">null</span> || startNo &gt; nums || startNo &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"WRONG INPUT!!!!"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Boy helper = first;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (helper.getNext() == first) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			helper = helper.getNext();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; startNo - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			helper = helper.getNext();</span><br><span class="line">			first = first.getNext();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (first.getNext() == first) &#123;</span><br><span class="line">				System.out.println(<span class="string">"最后留下的小孩是"</span> + first.getNo());</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; countNum - <span class="number">1</span>; i++) &#123;</span><br><span class="line">				first = first.getNext();</span><br><span class="line">				helper = helper.getNext();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(first.getNo() + <span class="string">"号小孩出圈~~~~"</span>);</span><br><span class="line">			helper.setNext(first.getNext());</span><br><span class="line">			first = first.getNext();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>出圈的顺序</p>
<p>2-&gt;4-&gt;1-&gt;5-&gt;3 </p>
<p>结果：</p>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191221/MyfIhFFDqaKi.png" alt="mark"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据结构与算法——链表</title>
    <url>/2019/12/19/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191219/QXv92AYeSPvA.jpg" alt="mark" style="zoom:200%;" />

<a id="more"></a>

<h2 id="Java数据结构与算法——链表"><a href="#Java数据结构与算法——链表" class="headerlink" title="Java数据结构与算法——链表"></a>Java数据结构与算法——链表</h2><p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191219/8utgPE1PonQ3.png" alt="mark"></p>
<ul>
<li>链表是以节点的方式来存储,是链式存储</li>
<li>每个节点包含 data 域， next 域：指向下一个节点.</li>
<li>发现链表的<strong>各个节点不一定是连续存储</strong>.</li>
<li>链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定</li>
</ul>
<h3 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1. 单链表"></a>1. 单链表</h3><h4 id="1-1-单链表的基本操作"><a href="#1-1-单链表的基本操作" class="headerlink" title="1.1 单链表的基本操作"></a>1.1 单链表的基本操作</h4><p>单链表(带头结点) 逻辑结构示意图如下：</p>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191219/wyctOYDNq0A5.png" alt="mark"></p>
<h5 id="1-1-1-增加节点"><a href="#1-1-1-增加节点" class="headerlink" title="1.1.1 增加节点"></a>1.1.1 增加节点</h5><p><strong>在末尾添加</strong></p>
<p>思路：遍历链表，当遍历到链表末尾时（temp.next == null），插入节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加节点到单向链表</span></span><br><span class="line"><span class="comment">// 思路，当不考虑编号顺序时</span></span><br><span class="line"><span class="comment">// 1. 找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">// 2. 将最后这个节点的next 指向 新的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(LinkedNode heroNode)</span> </span>&#123;</span><br><span class="line">	LinkedNode temp;</span><br><span class="line">	temp = getHead();</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			temp.next = heroNode;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp.next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>按顺序添加</strong></p>
<p>思路：遍历链表，当遍历到的节点的下一个节点的序号大于插入节点的序号，退出循环，插入节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line"><span class="comment">// (如果有这个排名，则添加失败，并给出提示)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(LinkedNode heroNode)</span> </span>&#123;</span><br><span class="line">	LinkedNode temp = getHead();</span><br><span class="line">	<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			temp.next = heroNode;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"存在%d号成员，无法添加\n"</span>, heroNode.no);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;</span><br><span class="line">			flag = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp.next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		heroNode.next = temp.next;</span><br><span class="line">		temp.next = heroNode;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-2-删除节点"><a href="#1-1-2-删除节点" class="headerlink" title="1.1.2 删除节点"></a>1.1.2 删除节点</h5><p>思路：</p>
<ol>
<li>先判断链表是否为空，若为空，直接删除失败；</li>
<li>遍历链表，找到要删除的节点的前一个节点；</li>
<li>将要删除的节点的前一个节点指向要删除的节点的下一个节点；</li>
<li>如果找不到要删除的节点，返回删除失败。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="comment">// 思路</span></span><br><span class="line"><span class="comment">// 1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span></span><br><span class="line"><span class="comment">// 2. 说明我们在比较时，是temp.next.no 和 需要删除的节点的no比较</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">		System.out.println(<span class="string">"链表为空~"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedNode temp = getHead();</span><br><span class="line">	<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">			flag = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp.next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// System.out.println("没有找到" + no + "号节点，无法修改！");</span></span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		temp.next = temp.next.next;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">"没有找到"</span> + no + <span class="string">"号节点，无法修改！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-3-修改节点"><a href="#1-1-3-修改节点" class="headerlink" title="1.1.3 修改节点"></a>1.1.3 修改节点</h5><p>思路：</p>
<ol>
<li><p>先判断链表是否为空，若为空，直接修改失败；</p>
<ol start="2">
<li>遍历链表，找到要修改的节点；</li>
<li>修改节点内容；</li>
<li>如果找不到要修改的节点，返回修改失败。</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改节点的信息, 根据no编号来修改，即no编号不能改.</span></span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 1. 根据 newHeroNode 的 no 来修改即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(LinkedNode newHeroNode)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">		System.out.println(<span class="string">"链表为空~"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedNode temp = getHead();</span><br><span class="line">	<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (temp.next.no == newHeroNode.no) &#123;</span><br><span class="line">			newHeroNode.next = temp.next.next;</span><br><span class="line">			temp.next = newHeroNode;</span><br><span class="line">			flag = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp.next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	System.out.println(<span class="string">"没有找到"</span> + newHeroNode.no + <span class="string">"号节点，无法修改！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-2-单链表的几个面试题"><a href="#1-2-单链表的几个面试题" class="headerlink" title="1.2 单链表的几个面试题"></a>1.2 单链表的几个面试题</h4><h5 id="1-2-1-求单链表中有效节点的个数"><a href="#1-2-1-求单链表中有效节点的个数" class="headerlink" title="1.2.1 求单链表中有效节点的个数"></a>1.2.1 求单链表中有效节点的个数</h5><p>思路：遍历链表，找到一个节点就让计数器加1，直到遍历到链表尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(LinkedNode head)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">		LinkedNode temp = head.next;</span><br><span class="line">		<span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">			length++;</span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> length;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-2-查找单链表中的倒数第k个结点"><a href="#1-2-2-查找单链表中的倒数第k个结点" class="headerlink" title="1.2.2 查找单链表中的倒数第k个结点"></a>1.2.2 查找单链表中的倒数第k个结点</h5><p>思路：</p>
<ol>
<li>编写一个方法，接收head节点，同时接收一个index</li>
<li>index 表示是倒数第index个节点</li>
<li>先把链表从头到尾遍历，得到链表的总的长度 getLength</li>
<li>得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到</li>
<li>如果找到了，则返回该节点，否则返回null</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找单链表中的倒数第k个结点 【新浪面试题】</span></span><br><span class="line"><span class="comment">// 思路</span></span><br><span class="line"><span class="comment">// 1. 编写一个方法，接收head节点，同时接收一个index</span></span><br><span class="line"><span class="comment">// 2. index 表示是倒数第index个节点</span></span><br><span class="line"><span class="comment">// 3. 先把链表从头到尾遍历，得到链表的总的长度 getLength</span></span><br><span class="line"><span class="comment">// 4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到</span></span><br><span class="line"><span class="comment">// 5. 如果找到了，则返回该节点，否则返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LinkedNode <span class="title">findLastIndexNode</span><span class="params">(LinkedNode head, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> length = SingleLinkedList.getLength(head);</span><br><span class="line">	<span class="keyword">if</span> (index &lt;= <span class="number">0</span> || index &gt; length) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedNode temp = head.next;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - index; i++) &#123;</span><br><span class="line">		temp = temp.next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-3-单链表的反转"><a href="#1-2-3-单链表的反转" class="headerlink" title="1.2.3 单链表的反转"></a>1.2.3 单链表的反转</h5><p>方式1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反转链表方式1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversetList</span><span class="params">(LinkedNode head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedNode temp = head;</span><br><span class="line">	LinkedNode reverseNode = <span class="keyword">new</span> LinkedNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">	LinkedNode reTEMP = reverseNode;</span><br><span class="line">	<span class="keyword">while</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">		temp = head;</span><br><span class="line">		<span class="keyword">while</span> (temp.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		reTEMP.next = temp.next;</span><br><span class="line">		reTEMP = reTEMP.next;</span><br><span class="line">		temp.next = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// break;</span></span><br><span class="line">	&#125;</span><br><span class="line">	head.next = reverseNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">revList</span><span class="params">(LinkedNode head)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 如果链表为空或只含有一个节点，直接返回</span></span><br><span class="line">  	<span class="keyword">if</span> (head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">  			<span class="keyword">return</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	LinkedNode cur = head.next;</span><br><span class="line">  	LinkedNode next;</span><br><span class="line">  	LinkedNode revhead = <span class="keyword">new</span> LinkedNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">  	<span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">  		next = cur.next;</span><br><span class="line">  		cur.next = revhead.next;</span><br><span class="line">  		revhead.next = cur;</span><br><span class="line">  		cur = next;</span><br><span class="line">  		&#125;</span><br><span class="line">  	head.next = revhead.next;</span><br><span class="line">  	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-4-从尾到头打印单链表"><a href="#1-2-4-从尾到头打印单链表" class="headerlink" title="1.2.4 从尾到头打印单链表"></a>1.2.4 从尾到头打印单链表</h5><p>方式1：反向遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1：</span></span><br><span class="line"><span class="comment">// 方向遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">revPrint</span><span class="params">(LinkedNode head)</span> </span>&#123;</span><br><span class="line">  	SingleLinkedList s1 = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">  	s1.head.next = head.next;</span><br><span class="line">  	<span class="keyword">int</span> length = SingleLinkedList.getLength(head);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">int</span> i = length; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">  		System.out.println(s1.getNode(i));</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式2：Stack栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式2：</span></span><br><span class="line"><span class="comment">// 可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">(LinkedNode head)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">  		<span class="keyword">return</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	Stack&lt;LinkedNode&gt; stack = <span class="keyword">new</span> Stack&lt;LinkedNode&gt;();</span><br><span class="line">  	LinkedNode temp = head.next;</span><br><span class="line">  	<span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">  		stack.add(temp);</span><br><span class="line">  		temp = temp.next;</span><br><span class="line">  	&#125;</span><br><span class="line"> 	<span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  		System.out.println(stack.pop());</span><br><span class="line">  	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-5-合并两个有序的单链表，合并之后的链表依然有序"><a href="#1-2-5-合并两个有序的单链表，合并之后的链表依然有序" class="headerlink" title="1.2.5 合并两个有序的单链表，合并之后的链表依然有序"></a>1.2.5 合并两个有序的单链表，合并之后的链表依然有序</h5><p>思路：遍历链表2，每找到一个节点就将其按顺序插入链表1，直到链表2为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 合并两个有序的单链表，合并之后的链表依然有序</span></span><br><span class="line"><span class="comment">// 合并后的链表头节点为head1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeList</span><span class="params">(LinkedNode head1, LinkedNode head2)</span> </span>&#123;</span><br><span class="line">	SingleLinkedList s1 = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">	SingleLinkedList s2 = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">	s1.head.next = head1.next;</span><br><span class="line">	s2.head.next = head2.next;</span><br><span class="line">	<span class="keyword">if</span> (s1.head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">		s1.head.next = s2.head.next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (s2.head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedNode temp = s2.head.next;</span><br><span class="line">	LinkedNode next = temp.next;</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		next = temp.next;</span><br><span class="line">		s1.addByOrder(temp);</span><br><span class="line">		temp = next;</span><br><span class="line">	&#125;</span><br><span class="line">	head1.next = s1.head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-双向链表"><a href="#2-双向链表" class="headerlink" title="2. 双向链表"></a>2. 双向链表</h3><h4 id="2-1-单向链表的缺点分析"><a href="#2-1-单向链表的缺点分析" class="headerlink" title="2.1 单向链表的缺点分析"></a>2.1 单向链表的缺点分析</h4><ul>
<li>单向链表，<strong>查找的方向只能是一个方向</strong>，而双向链表可以向前或者向后查找。</li>
<li>单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以<strong>自我删除</strong>，所以前面我们单链表删除时节点，总是找到temp,temp是待删除节点的前一个节点(认真体会).</li>
<li>示意图帮助理解删除 </li>
</ul>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191220/sSw2y0SsEwzo.png" alt="mark"></p>
<h4 id="2-2-双向链表的基本操作"><a href="#2-2-双向链表的基本操作" class="headerlink" title="2.2 双向链表的基本操作"></a>2.2 双向链表的基本操作</h4><h5 id="2-2-1-遍历"><a href="#2-2-1-遍历" class="headerlink" title="2.2.1 遍历"></a>2.2.1 遍历</h5><p>方法和单链表一样只是可以向前，也可以向后查找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示链表[遍历]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Node temp;</span><br><span class="line">	temp = head;</span><br><span class="line">	<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">		System.out.println(<span class="string">"队列为空"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp.next;</span><br><span class="line">		System.out.println(temp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-2-2-添加"><a href="#2-2-2-添加" class="headerlink" title="2.2.2 添加"></a>2.2.2 添加</h5><ul>
<li><p>默认添加到双向链表的最后</p>
<p>遍历双向链表，找到最后这个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">temp.next = newNode;</span><br><span class="line">newNode.pre = temp;<span class="comment">//比单链表多一步</span></span><br></pre></td></tr></table></figure>

<p>具体代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增加节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		Node temp = head;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				temp.next = node;</span><br><span class="line">				node.pre = temp;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>按顺序添加</p>
<p>按照单链表的顺序添加，稍作修改即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按顺序增加节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		Node temp = head;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">//flag = true;</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp.next.no == node.no) &#123;</span><br><span class="line">				System.out.printf(<span class="string">"%d号节点存在，无法添加！\n"</span>,node.no);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp.next.no &gt; node.no) &#123;</span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag) &#123;</span><br><span class="line">			temp.next.pre = node;</span><br><span class="line">			node.next = temp.next;</span><br><span class="line">			node.pre = temp;</span><br><span class="line">			temp.next = node;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			node.pre = temp;</span><br><span class="line">			temp.next = node;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h5 id="2-2-3-修改"><a href="#2-2-3-修改" class="headerlink" title="2.2.3 修改"></a>2.2.3 修改</h5><p>思路和单链表一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node newNode)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">		System.out.println(<span class="string">"链表为空，无法修改！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Node temp = head.next;</span><br><span class="line">	<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (temp.no == newNode.no) &#123;</span><br><span class="line">			flag = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp.next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		temp.name = newNode.name;</span><br><span class="line">		temp.nickname = newNode.nickname;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		System.out.printf(<span class="string">"没有找到%d号，无法修改！\n"</span>, newNode.no);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-2-4-删除"><a href="#2-2-4-删除" class="headerlink" title="2.2.4 删除"></a>2.2.4 删除</h5><p>双向链表可以实现自我删除，直接找打要删除的节点，不用像单链表一样找前一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">temp.pre.next = temp.next;</span><br><span class="line">temp.next.pre = temp.pre;<span class="comment">//这里可以把a = b读作把节点a指向节点b</span></span><br></pre></td></tr></table></figure>

<p>这里还要注意一点，当要删除的节点是链表最后一个节点时，不需要进行上述第二部操作，注意判别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">		System.out.println(<span class="string">"链表为空，无法删除！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Node temp = head.next;</span><br><span class="line">	<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (temp.no == index) &#123;</span><br><span class="line">			flag = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp.next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		temp.pre.next = temp.next;</span><br><span class="line">		<span class="keyword">if</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">			temp.next.pre = temp.pre;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		System.out.printf(<span class="string">"没有找到%d号，无法删除！\n"</span>, index);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令大全</title>
    <url>/2019/12/17/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191217/eiwfh4t4HxYl.jpg?imageslim" alt="mark" style="zoom:150%;" />

]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ecilpse快捷键大全</title>
    <url>/2019/12/17/Ecilpse%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p><img src="http://image.gwbiubiubiu.com/blog/20191218/2xVBxhp3kcwK.jpg" alt="mark"></p>
<a id="more"></a>

<h3 id="Eclipse中的快捷键"><a href="#Eclipse中的快捷键" class="headerlink" title="Eclipse中的快捷键"></a>Eclipse中的快捷键</h3><ol>
<li><p>补全代码的声明：alt + /</p>
</li>
<li><p>快速修复: ctrl + 1  </p>
</li>
<li><p>批量导包：ctrl + shift + o</p>
</li>
<li><p>使用单行注释：ctrl + /</p>
</li>
<li><p>使用多行注释： ctrl + shift + /   </p>
</li>
<li><p>取消多行注释：ctrl + shift + \</p>
</li>
<li><p>复制指定行的代码：ctrl + alt + down 或 ctrl + alt + up</p>
</li>
<li><p>删除指定行的代码：ctrl + d</p>
</li>
<li><p>上下移动代码：alt + up  或 alt + down</p>
</li>
<li><p>切换到下一行代码空位：shift + enter</p>
</li>
<li><p>切换到上一行代码空位：ctrl + shift + enter</p>
</li>
<li><p>如何查看源码：ctrl + 选中指定的结构   或  ctrl + shift + t</p>
</li>
<li><p>退回到前一个编辑的页面：alt + left </p>
</li>
<li><p>进入到下一个编辑的页面(针对于上面那条来说的)：alt + right</p>
</li>
<li><p>光标选中指定的类，查看继承树结构：ctrl + t</p>
</li>
<li><p>复制代码： ctrl + c</p>
</li>
<li><p>撤销： ctrl + z</p>
</li>
<li><p>反撤销： ctrl + y</p>
</li>
<li><p>剪切：ctrl + x </p>
</li>
<li><p>粘贴：ctrl + v</p>
</li>
<li><p>保存： ctrl + s</p>
</li>
<li><p>全选：ctrl + a</p>
</li>
<li><p>格式化代码： ctrl + shift + f</p>
</li>
<li><p>选中数行，整体往后移动：tab</p>
</li>
<li><p>选中数行，整体往前移动：shift + tab</p>
</li>
<li><p>在当前类中，显示类结构，并支持搜索指定的方法、属性等：ctrl + o</p>
</li>
<li><p>批量修改指定的变量名、方法名、类名等：alt + shift + r</p>
</li>
<li><p>选中的结构的大小写的切换：变成大写： ctrl + shift + x</p>
</li>
<li><p>选中的结构的大小写的切换：变成小写：ctrl + shift + y</p>
</li>
<li><p>调出生成getter/setter/构造器等结构： alt + shift + s</p>
</li>
<li><p>显示当前选择资源(工程 or 文件)的属性：alt + enter</p>
</li>
<li><p>快速查找：参照选中的Word快速定位到下一个 ：ctrl + k</p>
</li>
<li><p>关闭当前窗口：ctrl + w</p>
</li>
<li><p>关闭所有的窗口：ctrl + shift + w</p>
</li>
<li><p>查看指定的结构使用过的地方：ctrl + alt + g</p>
</li>
<li><p>查找与替换：ctrl + f</p>
</li>
<li><p>最大化当前的View：ctrl + m</p>
</li>
<li><p>直接定位到当前行的首位：home</p>
</li>
<li><p>直接定位到当前行的末位：end</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Eclipse</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法总结</title>
    <url>/2019/12/17/Markdown%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191217/wEYEHBJMNkFg.jpg?imageslim" alt="mark" style="zoom:150%;" />

<a id="more"></a>

<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
<p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p>
<p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>
<p>Markdown 编写的文档后缀为 <strong>.md</strong>, <strong>.markdown</strong>。</p>
<h3 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h3><h4 id="使用-号标记"><a href="#使用-号标记" class="headerlink" title="使用 # 号标记"></a>使用 # 号标记</h4><p>使用<kbd> #</kbd> 号可表示 1-6 级标题，一级标题对应一个<kbd> #</kbd> 号，二级标题对应两个<kbd> #</kbd> 号，以此类推。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>

<h4 id="使用-和-标记一级和二级标题"><a href="#使用-和-标记一级和二级标题" class="headerlink" title="使用 = 和 - 标记一级和二级标题"></a>使用 = 和 - 标记一级和二级标题</h4><p>= 和 - 标记语法格式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">我展示的是一级标题</span><br><span class="line">=================</span><br><span class="line"></span><br><span class="line">我展示的是二级标题</span><br><span class="line">-----------------</span><br></pre></td></tr></table></figure>

<h3 id="Markdown-段落"><a href="#Markdown-段落" class="headerlink" title="Markdown 段落"></a>Markdown 段落</h3><p>Markdown 段落没有特殊的格式，直接编写文字就好，<strong>段落的换行是使用两个以上空格加上回车</strong>。</p>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>Markdown 可以使用以下几种字体：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体文本*</span></span><br><span class="line"><span class="emphasis">_斜体文本_</span></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line"><span class="strong">__粗体文本__</span></span><br><span class="line"><span class="strong">***粗斜体文本**</span>*</span><br><span class="line"><span class="strong">___粗斜体文本__</span>_</span><br></pre></td></tr></table></figure>

<h3 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h3><p>Markdown 支持有序列表和无序列表。</p>
<p>无序列表使用星号(<strong>***)、加号(</strong>+<strong>)或是减号(</strong>-**)作为列表标记：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>第一项</span><br><span class="line"><span class="bullet">* </span>第二项</span><br><span class="line"><span class="bullet">* </span>第三项</span><br><span class="line"></span><br><span class="line"><span class="bullet">+ </span>第一项</span><br><span class="line"><span class="bullet">+ </span>第二项</span><br><span class="line"><span class="bullet">+ </span>第三项</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>第一项</span><br><span class="line"><span class="bullet">- </span>第二项</span><br><span class="line"><span class="bullet">- </span>第三项</span><br></pre></td></tr></table></figure>

<p>有序列表使用数字并加上 <strong>.</strong> 号来表示，如</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>第一项</span><br><span class="line"><span class="bullet">2. </span>第二项</span><br><span class="line"><span class="bullet">3. </span>第三项</span><br></pre></td></tr></table></figure>

<p>列表嵌套只需在子列表中的选项添加四个空格即可：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>第一项：</span><br><span class="line"><span class="bullet">    - </span>第一项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    - </span>第一项嵌套的第二个元素</span><br><span class="line"><span class="bullet">2. </span>第二项：</span><br><span class="line"><span class="bullet">    - </span>第二项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    - </span>第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure>

<h3 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h3><p>Markdown 区块引用是在段落开头使用 <strong>&gt;</strong> 符号 ，然后后面紧跟一个<strong>空格</strong>符号：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 区块引用1</span></span><br><span class="line"><span class="quote">&gt; 区块引用2</span></span><br><span class="line"><span class="quote">&gt; 区块引用3</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>语法笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>个人博客</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客系统搭建——经验总结</title>
    <url>/2019/12/17/Hexo+Github%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<img src="http://image.gwbiubiubiu.com/blog/20191217/h1vQm1zqT88I.jpg?imageslim" alt="mark" style="zoom:150%;" />

<a id="more"></a>

<h1 id="Hexo博客系统搭建——经验总结"><a href="#Hexo博客系统搭建——经验总结" class="headerlink" title="Hexo博客系统搭建——经验总结"></a>Hexo博客系统搭建——经验总结</h1><p>Hexo是一个基于node.js制作的一个轻量静态博客工具，有很多的主题可供定制化，对中文用户也很友好。</p>
<p>主页：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p>
<p><img src="http://image.gwbiubiubiu.com/blog/20191216/NLBzdnlHBqOC.png?imageslim" alt="mark"></p>
<p>下面我们就一起开始用Hexo来搭建属于自己的个人博客把。</p>
<p>【注】笔者用的是Windows系统，所以大部分操作是在cmd上完成的，如果使用Mac或者Linux应该大同小异，就不再赘述了。</p>
<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>因为Hexo是基于Node.js 开发的，所以肯定是需要安装node.js的，这个直接去官网下载安装包就行，安装后可以输入以下命令查看版本号，用于验证自己是否正确安装。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">$ node -v</span><br></pre></td></tr></table></figure>

<p>显示版本号表示成功安装：</p>
<p><img src="http://image.gwbiubiubiu.com/blog/20191216/HT6PTdeCeeEd.png?imageslim" alt="mark"></p>
<h2 id="安装cnpm"><a href="#安装cnpm" class="headerlink" title="安装cnpm"></a>安装cnpm</h2><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2>]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title>使用七牛云搭建个人免费图床</title>
    <url>/2019/12/17/%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191217/gsPut9AvGaRr.jpg" alt="mark"></p>
<a id="more"></a>

<p><img src="%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/image-20200102094721845.png" alt="image-20200102094721845"></p>
]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>Hexo</tag>
        <tag>ECS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识——继承与多态</title>
    <url>/2019/12/15/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p><img src="http://image.gwbiubiubiu.com/blog/20191216/adLGkvzIH0c5.jpg?imageslim" alt="mark"><br> <a id="more"></a> </p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>《Java核心技术 卷I》第五章 本章主要内容是Java中继承的相关知识。</p>
<h2 id="类、超类和子类"><a href="#类、超类和子类" class="headerlink" title="类、超类和子类"></a>类、超类和子类</h2><p>“is-a”关系是继承的一个明显特征</p>
<h3 id="定义子类"><a href="#定义子类" class="headerlink" title="定义子类"></a>定义子类</h3><p>关键字extends表示继承</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//添加方法和域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>已存在的类：父类、超类或基类</p>
<p>新类：子类、派生类或孩子类</p>
<p>子类比超类拥有的功能更加丰富，封装了更多数据、拥有更多功能。</p>
<h3 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h3><p>子类不能直接访问超类的私有域</p>
<p>super.方法 指示编译器调用超类的方法的特殊关键字</p>
<h3 id="子类构造器"><a href="#子类构造器" class="headerlink" title="子类构造器"></a>子类构造器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, salary, year, month, day);<span class="comment">//调用超类中含有name, salary, year, month, day参数的构造器</span></span><br><span class="line">    bonus = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>manage类不能访问employee类的私有域</p>
<p>使用super实现对超类构造器的调用，super必须是子类构造器的第一条语句</p>
<p>多态：一个变量对象可以指示多种实际类型的现象被称为<strong>多态</strong>，在运行时能够自动的选择调用哪个方法的现象称为<strong>动态绑定</strong>。</p>
<h3 id="继承层次"><a href="#继承层次" class="headerlink" title="继承层次"></a>继承层次</h3><p>由一个公共超类派生出来的所有类的集合</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>程序中出现超类对象对任何地方都可以引用子类对象置换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee e;</span><br><span class="line">e = <span class="keyword">new</span> Employee(...);<span class="comment">//</span></span><br><span class="line">e = <span class="keyword">new</span> Manger(...);<span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p>在Java程序设计语言中，对象变量是<strong>多态</strong>的。一个Employee变量既可以引用一个Employee类对象，也可以引用一个Employee类对任何一个子类的对象。</p>
<ol>
<li>理解多态性：可以理解为一个事物的多种形态。</li>
<li>何为多态性：对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）</li>
<li>多态的使用：虚拟方法调用 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。</li>
<li>多态性的使用前提：  ① 类的继承关系  ② 方法的重写</li>
<li>对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</li>
</ol>
<h3 id="instanceof-关键字"><a href="#instanceof-关键字" class="headerlink" title="instanceof 关键字"></a>instanceof 关键字</h3><p>有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。</p>
<p><strong>如何才能调用子类特有的属性和方法？</strong></p>
<p>答：向下转型：使用强制类型转换符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Man m1 = (Man)p2;</span><br></pre></td></tr></table></figure>

<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191217/oQ9iChTS5NSU.png?imageslim" alt="mark"></p>
<p>使用强转时，可能出现ClassCastException的异常，故引入instanceof关键字。</p>
<p><strong>instanceof关键字的使用</strong>：a instanceof A:判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false。</p>
<blockquote>
<p>使用情境：为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。<br>如果 a instanceof A返回true,则 a instanceof B也返回true。其中，类B是类A的父类。</p>
</blockquote>
<p>需要注意的几个问题：</p>
<p>问题一：编译时通过，运行时不通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p3 = <span class="keyword">new</span> Woman();</span><br><span class="line">Man m3 = (Man)p3;</span><br></pre></td></tr></table></figure>

<p>问题二：编译通过，运行时也通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Woman();</span><br><span class="line">Person p = (Person)obj;</span><br></pre></td></tr></table></figure>

<p>问题三：编译不通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Man m5 = <span class="keyword">new</span> Woman();</span><br><span class="line">String str = <span class="keyword">new</span> Date();</span><br></pre></td></tr></table></figure>

<p>子类继承父类</p>
<ul>
<li>若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的 同名方法，系统将不可能把父类里的方法转移到子类中。</li>
<li>对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的 实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量。</li>
</ul>
<h3 id="Object类结构分析"><a href="#Object类结构分析" class="headerlink" title="Object类结构分析"></a>Object类结构分析</h3><ol>
<li><p>Object类是所有Java类的根父类</p>
</li>
<li><p>如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类 </p>
</li>
<li><p>Object类中的功能(属性、方法)就具有通用性。</p>
<p>属性：无</p>
<p>方法：equals() / toString() / getClass() /hashCode() / clone() / finalize()/wait() 、notify()、notifyAll()</p>
</li>
<li><p>Object类只声明了一个空参的构造器</p>
</li>
</ol>
<p><strong>equals()</strong></p>
<ol>
<li><p>回顾 == 的使用</p>
<ul>
<li><p>可以使用在基本数据类型变量和引用数据类型变量中</p>
</li>
<li><p>如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）</p>
</li>
<li><p>如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</p>
</li>
<li><p>== 符号使用时，必须保证符号左右两边的变量类型一致</p>
</li>
</ul>
</li>
<li><p>equals()方法的使用</p>
<ul>
<li><p>是一个方法，而非运算符</p>
</li>
<li><p>只能适用于引用数据类型</p>
</li>
<li><p>Object类中equals()的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">	  &#125;</span><br><span class="line"><span class="comment">//Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同。</p>
</li>
<li><p>通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的”实体内容”是否相同。那么，我们就需要对Object类中的equals()进行重写。</p>
</li>
</ul>
</li>
<li><p>重写equals()方法的原则</p>
<ul>
<li><p>对称性：如果x.equals(y)返回是“true” ，那么y.equals(x)也应该返回是 “true”。</p>
</li>
<li><p>自反性：x.equals(x)必须返回是“true”。</p>
</li>
<li><p>传递性：如果x.equals(y)返回是“true” ，而且y.equals(z)返回是“true” ， 那么z.equals(x)也应该返回是“true”。</p>
</li>
<li><p>一致性：如果x.equals(y)返回是“true” ，只要x和y内容一直不变，不管你 重复x.equals(y)多少次，返回都是“true”。</p>
</li>
<li><p>任何情况下，x.equals(null)，永远返回是“false” ；</p>
<p> x.equals(和x不同类型的对象)永远返回是“false”。</p>
</li>
</ul>
</li>
</ol>
<p><strong>toString()</strong></p>
<p>Object类中toString()的使用：</p>
<ol>
<li><p>当我们输出一个对象的引用时，实际上就是调用当前对象的toString()。</p>
</li>
<li><p>Object类中toString()的定义：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getClass().getName()+<span class="string">"@"</span>+Integer.toHexString(hashCode());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>像String、Date、File、包装类等都重写了Object类中的toString()方法。使得在调用对象的toString()时，返回”实体内容”信息。</li>
<li>自定义类也可以重写toString()方法，当调用此方法时，返回对象的”实体内容”。</li>
</ol>
<h3 id="Java中的JUnit单元测试"><a href="#Java中的JUnit单元测试" class="headerlink" title="Java中的JUnit单元测试"></a>Java中的JUnit单元测试</h3><p><strong>步骤：</strong></p>
<ol>
<li><p>选中当前工程 - 右键选择：build path - add libraries - JUnit 4 - 下一步</p>
</li>
<li><p>创建Java类，进行单元测试。此时的Java类要求：① 此类是public的  ②此类提供公共的无参的构造器</p>
</li>
<li><p>此类中声明单元测试方法。此时的单元测试方法：方法的权限是public,没有返回值，没有形参</p>
</li>
<li><p>此单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.junit.Test;</p>
</li>
<li><p>声明好单元测试方法以后，就可以在方法体内测试相关的代码。</p>
</li>
<li><p>写完代码以后，左键双击单元测试方法名，右键：run as - JUnit Test</p>
</li>
</ol>
<p><strong>说明：</strong></p>
<p>1.如果执行结果没有任何异常：绿条</p>
<p>2.如果执行结果出现异常：红条</p>
<h3 id="包装类的使用"><a href="#包装类的使用" class="headerlink" title="包装类的使用"></a>包装类的使用</h3><ol>
<li><p>Java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征</p>
</li>
<li><p>掌握的：基本数据类型、包装类、String三者之间的相互转换</p>
</li>
</ol>
<p>总结：基本类型、包装与 String类间的转换:</p>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191218/dxFknG46u8Vy.png" alt="mark"></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java实战——客户管理软件项目</title>
    <url>/2019/12/13/Java%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%AE%A2%E6%88%B7%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191220/C8y9gctBLzJK.jpg" alt="mark"></p>
<a id="more"></a> 

<p><em>写在最前</em></p>
<p><em>经过了一段时间的学习，下面通过一个简单客户管理软件项目复习一下学过的知识点。</em></p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ol>
<li>模拟实现一个基于文本界面的《客户信息管理软件》</li>
<li>进一步掌握编程技巧和调试技巧，熟悉面向对象编程</li>
<li>主要涉及以下知识点：</li>
</ol>
<ul>
<li>类结构的使用：属性、方法及构造器</li>
<li>对象的创建与使用</li>
<li>类的封装性</li>
<li>声明和使用数组</li>
<li>数组的插入、删除和替换</li>
<li>关键字的使用：this</li>
</ul>
<h3 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h3><p>模拟实现基于文本界面的《客户信息管理软件》。</p>
<p>该软件能够实现对客户对象的插入、修改和删除（用数组实现），并能够打印客户明细表。</p>
<h3 id="软件设计结构"><a href="#软件设计结构" class="headerlink" title="软件设计结构"></a>软件设计结构</h3><p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191220/qYwOgp2EMTRY.png" alt="mark"></p>
<ol>
<li>CustomerView为主模块，负责菜单的显示和处理用户操作</li>
<li>CustomerList为Customer对象的管理模块，内部用数组管理一组Customer对象，并提供相应的添加、修改、删除和遍历方法，供CustomerView调用</li>
<li>Customer为实体对象，用来封装客户信息</li>
</ol>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><h4 id="1-键盘访问的实现"><a href="#1-键盘访问的实现" class="headerlink" title="1. 键盘访问的实现"></a>1. 键盘访问的实现</h4><p>项目中提供了CMUtility.java类，可用来方便地实现键盘访问。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gaowei.endpoint.util;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">CMUtility工具类：</span></span><br><span class="line"><span class="comment">将不同的功能封装为方法，就是可以直接通过调用方法使用它的功能，而无需考虑具体的功能实现细节。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CMUtility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	用于界面菜单的选择。该方法读取键盘，如果用户键入’1’-’5’中的任意字符，则方法返回。返回值为用户键入字符。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">readMenuSelection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            String str = readKeyBoard(<span class="number">1</span>, <span class="keyword">false</span>);</span><br><span class="line">            c = str.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">'1'</span> &amp;&amp; c != <span class="string">'2'</span> &amp;&amp; </span><br><span class="line">                c != <span class="string">'3'</span> &amp;&amp; c != <span class="string">'4'</span> &amp;&amp; c != <span class="string">'5'</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">"选择错误，请重新输入："</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	从键盘读取一个字符，并将其作为方法的返回值。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">readChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str = readKeyBoard(<span class="number">1</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	从键盘读取一个字符，并将其作为方法的返回值。</span></span><br><span class="line"><span class="comment">	如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">readChar</span><span class="params">(<span class="keyword">char</span> defaultValue)</span> </span>&#123;</span><br><span class="line">        String str = readKeyBoard(<span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> (str.length() == <span class="number">0</span>) ? defaultValue : str.charAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	从键盘读取一个长度不超过2位的整数，并将其作为方法的返回值。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            String str = readKeyBoard(<span class="number">2</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                n = Integer.parseInt(str);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                System.out.print(<span class="string">"数字输入错误，请重新输入："</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	从键盘读取一个长度不超过2位的整数，并将其作为方法的返回值。</span></span><br><span class="line"><span class="comment">	如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">readInt</span><span class="params">(<span class="keyword">int</span> defaultValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            String str = readKeyBoard(<span class="number">2</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (str.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> defaultValue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                n = Integer.parseInt(str);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                System.out.print(<span class="string">"数字输入错误，请重新输入："</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	从键盘读取一个长度不超过limit的字符串，并将其作为方法的返回值。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readString</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readKeyBoard(limit, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	从键盘读取一个长度不超过limit的字符串，并将其作为方法的返回值。</span></span><br><span class="line"><span class="comment">	如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readString</span><span class="params">(<span class="keyword">int</span> limit, String defaultValue)</span> </span>&#123;</span><br><span class="line">        String str = readKeyBoard(limit, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> str.equals(<span class="string">""</span>)? defaultValue : str;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	用于确认选择的输入。该方法从键盘读取‘Y’或’N’，并将其作为方法的返回值。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">readConfirmSelection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            String str = readKeyBoard(<span class="number">1</span>, <span class="keyword">false</span>).toUpperCase();</span><br><span class="line">            c = str.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'Y'</span> || c == <span class="string">'N'</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(<span class="string">"选择错误，请重新输入："</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readKeyBoard</span><span class="params">(<span class="keyword">int</span> limit, <span class="keyword">boolean</span> blankReturn)</span> </span>&#123;</span><br><span class="line">        String line = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            line = scanner.nextLine();</span><br><span class="line">            <span class="keyword">if</span> (line.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (blankReturn) <span class="keyword">return</span> line;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (line.length() &lt; <span class="number">1</span> || line.length() &gt; limit) &#123;</span><br><span class="line">                System.out.print(<span class="string">"输入长度（不大于"</span> + limit + <span class="string">"）错误，请重新输入："</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> line;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-Customer类的设计"><a href="#2-Customer类的设计" class="headerlink" title="2. Customer类的设计"></a>2. Customer类的设计</h4><ul>
<li><p>按照设计要求编写Customer类，并编译。</p>
</li>
<li><p>在Customer 类中临时添加一个main方法中，作为单元测试方法。在方法中创建Customer对象，并调用对象的各个方法，以测试该类是否编写正确。</p>
</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gaowei.endpoint.bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: Customer.java  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gaowei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span> com.gaowei.endpoint.bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Customer为实体类，用来封装客户信息 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019年12月11日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">	String name  ;<span class="comment">//客户姓名</span></span><br><span class="line">	<span class="keyword">char</span> gender  ;<span class="comment">//性别</span></span><br><span class="line">	<span class="keyword">int</span> age      ;<span class="comment">//年龄</span></span><br><span class="line">	String phone ;<span class="comment">//电话号码</span></span><br><span class="line">	String email ;<span class="comment">//电子邮箱</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> gender;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(<span class="keyword">char</span> gender)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.gender = gender;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> phone;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhone</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.phone = phone;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> email;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.email = email;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//super();</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String name, <span class="keyword">char</span> gender, <span class="keyword">int</span> age, String phone, String email)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//super();</span></span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.gender = gender;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		<span class="keyword">this</span>.phone = phone;</span><br><span class="line">		<span class="keyword">this</span>.email = email;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-CustomerList类的设计"><a href="#3-CustomerList类的设计" class="headerlink" title="3. CustomerList类的设计"></a>3. CustomerList类的设计</h4><p><strong>CustomerList</strong>为Customer对象的管理模块，内部使用数组管理一组Customer对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gaowei.endpoint.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gaowei.endpoint.bean.Customer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: CustomerList.java  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gaowei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span> com.gaowei.endpoint.service</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: CustomerList为Customer对象的管理模块，内部使用数组管理一组Customer对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019年12月11日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Customer[] customers; <span class="comment">// 用来保存客户对象的数组</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">0</span>; <span class="comment">// 记录已保存客户对象的数量</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> gaowei</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@TODO</span> 测试功能用</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/*	</span></span><br><span class="line"><span class="comment">	public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">		CustomerList cList = new CustomerList(10);</span></span><br><span class="line"><span class="comment">		Customer aCustomer = new Customer("aa",'1', 18, "11","11");</span></span><br><span class="line"><span class="comment">		Customer bCustomer = new Customer("bb",'1', 18, "11","11");</span></span><br><span class="line"><span class="comment">		Customer cCustomer = new Customer("cc",'1', 18, "11","11");</span></span><br><span class="line"><span class="comment">		Customer dCustomer = new Customer("dd",'1', 18, "11","11");</span></span><br><span class="line"><span class="comment">		Customer eCustomer = new Customer("ee",'1', 18, "11","11");</span></span><br><span class="line"><span class="comment">		cList.addCustomer(aCustomer);</span></span><br><span class="line"><span class="comment">		cList.addCustomer(bCustomer);</span></span><br><span class="line"><span class="comment">		cList.addCustomer(cCustomer);</span></span><br><span class="line"><span class="comment">		cList.addCustomer(dCustomer);</span></span><br><span class="line"><span class="comment">		cList.addCustomer(eCustomer);</span></span><br><span class="line"><span class="comment">		Customer[] cust = cList.getAllCustomers();		</span></span><br><span class="line"><span class="comment">		System.out.println("加入成员后：");			</span></span><br><span class="line"><span class="comment">		System.out.println(cList.getTotal());</span></span><br><span class="line"><span class="comment">		for (int i = 0; i &lt; cust.length; i++) &#123;</span></span><br><span class="line"><span class="comment">			System.out.println(cust[i].getName());</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">				</span></span><br><span class="line"><span class="comment">		cList.deleteCustomer(2);</span></span><br><span class="line"><span class="comment">		cList.deleteCustomer(1);</span></span><br><span class="line"><span class="comment">		cust = cList.getAllCustomers();</span></span><br><span class="line"><span class="comment">		System.out.println("删去成员后：");	</span></span><br><span class="line"><span class="comment">		System.out.println(cList.getTotal());</span></span><br><span class="line"><span class="comment">		for (int i = 0; i &lt; cust.length; i++) &#123;</span></span><br><span class="line"><span class="comment">			System.out.println(cust[i].getName());</span></span><br><span class="line"><span class="comment">		&#125;		</span></span><br><span class="line"><span class="comment">		cList.replaceCustomer(1, aCustomer);</span></span><br><span class="line"><span class="comment">		cust = cList.getAllCustomers();</span></span><br><span class="line"><span class="comment">		System.out.println("替换成员后：");	</span></span><br><span class="line"><span class="comment">		System.out.println(cList.getTotal());</span></span><br><span class="line"><span class="comment">		for (int i = 0; i &lt; cust.length; i++) &#123;</span></span><br><span class="line"><span class="comment">			System.out.println(cust[i].getName());</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">			</span></span><br><span class="line"><span class="comment">		Customer fCustomer = new Customer();  </span></span><br><span class="line"><span class="comment">		fCustomer = cList.getCustomer(2);</span></span><br><span class="line"><span class="comment">		System.out.println(fCustomer.getName());</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@TODO</span> 用途：构造器，用来初始化customers数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> totalCustomer: 指定customers数组的最大空间</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CustomerList</span><span class="params">(<span class="keyword">int</span> totalCustomer)</span> </span>&#123;</span><br><span class="line">		customers = <span class="keyword">new</span> Customer[totalCustomer];</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@TODO</span> 将参数customer添加到数组中最后一个客户对象记录之后</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> customer 指定要添加的客户对象 </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 添加成功返回true；false表示数组已满，无法添加</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addCustomer</span><span class="params">(Customer customer)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(total == customers.length) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		customers[total] = customer;</span><br><span class="line">		total++;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@TODO</span> 用参数customer替换数组中由index指定的对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index 指定所替换对象在数组中的位置，从0开始</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> cust 指定替换的新客户对象 </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 替换成功返回true；false表示索引无效，无法替换</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replaceCustomer</span><span class="params">(<span class="keyword">int</span> index, Customer cust)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= total) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		customers[index] = cust;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@TODO</span> 从数组中删除参数index指定索引位置的客户对象记录</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index指定所删除对象在数组中的索引位置，从0开始</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 删除成功返回true；false表示索引无效，无法删除</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteCustomer</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= total) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; total; i++) &#123;</span><br><span class="line">			customers[i] = customers[i+<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		total--;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@TODO</span> 返回数组中记录的所有客户对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> Customer[] 数组中包含了当前所有客户对象，该数组长度与对象个数相同</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> Customer[] getAllCustomers() &#123;</span><br><span class="line">		Customer[] cust = <span class="keyword">new</span> Customer[total];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">			cust[i] = customers[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cust;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@TODO</span> 返回参数index指定索引位置的客户对象记录</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index指定所要获取的客户在数组中的索引位置，从0开始</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 封装了客户信息的Customer对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Customer <span class="title">getCustomer</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">		customer = customers[index];</span><br><span class="line">		<span class="keyword">return</span> customer;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span> </span>&#123;		</span><br><span class="line">		<span class="keyword">return</span> total;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-CustomerView类的设计"><a href="#4-CustomerView类的设计" class="headerlink" title="4. CustomerView类的设计"></a>4. CustomerView类的设计</h4><p><strong>CustomerView</strong>为主模块，负责菜单的显示和处理用户操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gaowei.endpoint.ui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gaowei.endpoint.service.CustomerList;</span><br><span class="line"><span class="keyword">import</span> com.gaowei.endpoint.bean.Customer;</span><br><span class="line"><span class="keyword">import</span> com.gaowei.endpoint.util.CMUtility;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: CustomerView.java  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gaowei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span> com.gaowei.endpoint.ui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: CustomerView为主模块，负责菜单的显示和处理用户操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019年12月11日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerView</span> </span>&#123;</span><br><span class="line">	CustomerList customerList = <span class="keyword">new</span> CustomerList(<span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@todo</span> 显示主菜单，响应用户输入，根据用户操作分别调用</span></span><br><span class="line"><span class="comment">	 * 		   其他相应的成员方法（如addNewCustomer），以完成客户信息处理。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enterMainMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> isFlag = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">while</span> (isFlag) &#123;</span><br><span class="line">			System.out.println(<span class="string">"\n-----------------客户信息管理软件-----------------\n"</span>);</span><br><span class="line">			System.out.println(<span class="string">"                   1 添 加 客 户"</span>);</span><br><span class="line">			System.out.println(<span class="string">"                   2 修 改 客 户"</span>);</span><br><span class="line">			System.out.println(<span class="string">"                   3 删 除 客 户"</span>);</span><br><span class="line">			System.out.println(<span class="string">"                   4 客 户 列 表"</span>);</span><br><span class="line">			System.out.println(<span class="string">"                   5 退       出\n"</span>);</span><br><span class="line">			System.out.print(<span class="string">"                   请选择(1-5)："</span>);</span><br><span class="line">			<span class="keyword">char</span> key = CMUtility.readMenuSelection();</span><br><span class="line">			<span class="keyword">switch</span> (key) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'1'</span>:</span><br><span class="line">				addNewCustomer();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'2'</span>:</span><br><span class="line">				modifyCustomer();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'3'</span>:</span><br><span class="line">				deleteCustomer();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'4'</span>:</span><br><span class="line">				listAllCustomers();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'5'</span>:</span><br><span class="line">				System.out.print(<span class="string">"是否确认退出(Y/N):"</span>);</span><br><span class="line">				<span class="keyword">if</span>( CMUtility.readConfirmSelection() == <span class="string">'Y'</span>)</span><br><span class="line">					isFlag = <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addNewCustomer</span><span class="params">()</span> </span>&#123;		</span><br><span class="line">		System.out.println(<span class="string">"---------------------添加客户---------------------"</span>);</span><br><span class="line">		System.out.print(<span class="string">"姓名："</span>);</span><br><span class="line">		String name = CMUtility.readString(<span class="number">5</span>);</span><br><span class="line">		System.out.print(<span class="string">"性别："</span>);</span><br><span class="line">		<span class="keyword">char</span> gender = CMUtility.readChar(<span class="string">'男'</span>);</span><br><span class="line">		System.out.print(<span class="string">"年龄："</span>);</span><br><span class="line">		<span class="keyword">int</span> age = CMUtility.readInt();</span><br><span class="line">		System.out.print(<span class="string">"电话："</span>);</span><br><span class="line">		String phone = CMUtility.readString(<span class="number">13</span>);</span><br><span class="line">		System.out.print(<span class="string">"邮箱："</span>);</span><br><span class="line">		String email = CMUtility.readString(<span class="number">30</span>);</span><br><span class="line">		Customer customer = <span class="keyword">new</span> Customer(name, gender, age, phone, email);</span><br><span class="line">		<span class="keyword">boolean</span> isFlag = customerList.addCustomer(customer);</span><br><span class="line">		<span class="keyword">if</span>(isFlag) &#123;</span><br><span class="line">			System.out.println(<span class="string">"---------------------添加完成---------------------"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"----------------记录已满,无法添加-----------------"</span>);</span><br><span class="line">		&#125;				</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">modifyCustomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"---------------------------修改客户---------------------------"</span>);</span><br><span class="line">		System.out.print(<span class="string">"请选择待修改客户编号(-1退出)："</span>);</span><br><span class="line">		<span class="keyword">int</span> index = CMUtility.readInt();</span><br><span class="line">		<span class="keyword">if</span>(index == -<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			</span><br><span class="line">			Customer[] customers = customerList.getAllCustomers();</span><br><span class="line">			Customer cust = customerList.getCustomer(index-<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(cust == <span class="keyword">null</span>) &#123;</span><br><span class="line">				System.out.println(<span class="string">"无法找到指定客户！"</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.print(<span class="string">"姓名"</span> + <span class="string">'('</span> + customers[index-<span class="number">1</span>].getName() + <span class="string">"):"</span>);</span><br><span class="line">			String name = CMUtility.readString(<span class="number">5</span>,customers[index-<span class="number">1</span>].getName());</span><br><span class="line">			System.out.print(<span class="string">"性别"</span> + <span class="string">'('</span> + customers[index-<span class="number">1</span>].getGender() + <span class="string">"):"</span>);</span><br><span class="line">			<span class="keyword">char</span> gender = CMUtility.readChar(customers[index-<span class="number">1</span>].getGender());</span><br><span class="line">			System.out.print(<span class="string">"年龄"</span> + <span class="string">'('</span> + customers[index-<span class="number">1</span>].getAge() + <span class="string">"):"</span>);</span><br><span class="line">			<span class="keyword">int</span> age = CMUtility.readInt(customers[index-<span class="number">1</span>].getAge());</span><br><span class="line">			System.out.print(<span class="string">"电话"</span> + <span class="string">'('</span> + customers[index-<span class="number">1</span>].getPhone() + <span class="string">"):"</span>);</span><br><span class="line">			String phone = CMUtility.readString(<span class="number">13</span>,customers[index-<span class="number">1</span>].getPhone());</span><br><span class="line">			System.out.print(<span class="string">"邮箱"</span> + <span class="string">'('</span> + customers[index-<span class="number">1</span>].getEmail() + <span class="string">"):"</span>);</span><br><span class="line">			String email = CMUtility.readString(<span class="number">30</span>,customers[index-<span class="number">1</span>].getEmail());</span><br><span class="line">			cust = <span class="keyword">new</span> Customer(name, gender, age, phone, email);</span><br><span class="line">			<span class="keyword">boolean</span> isflag = customerList.replaceCustomer(index - <span class="number">1</span>, cust);</span><br><span class="line">			<span class="keyword">if</span>(isflag) &#123;</span><br><span class="line">				System.out.println(<span class="string">"---------------------修改完成---------------------"</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"----------无法找到指定客户,修改失败--------------"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteCustomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"---------------------------删除客户---------------------------"</span>);</span><br><span class="line">		System.out.print(<span class="string">"请选择待删除客户编号(-1退出)："</span>);</span><br><span class="line">		<span class="keyword">int</span> index = CMUtility.readInt();</span><br><span class="line">		<span class="keyword">if</span>(index == -<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"确认是否删除(Y/N)："</span>);</span><br><span class="line">			<span class="keyword">char</span> key = CMUtility.readConfirmSelection();</span><br><span class="line">			<span class="keyword">if</span>(key == <span class="string">'Y'</span>) &#123;</span><br><span class="line">				<span class="keyword">boolean</span> isFlag = customerList.deleteCustomer(index - <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">if</span>(isFlag) &#123;</span><br><span class="line">					System.out.println(<span class="string">"---------------------------删除完成---------------------------"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					System.out.println(<span class="string">"----------无法找到指定客户,删除失败--------------"</span>);</span><br><span class="line">				&#125;			</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">listAllCustomers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"---------------------------客户列表---------------------------"</span>);</span><br><span class="line">		Customer[] cust = customerList.getAllCustomers();</span><br><span class="line">		System.out.println(<span class="string">"编号\t姓名\t性别\t年龄\t电话\t\t邮箱"</span>);</span><br><span class="line">		<span class="keyword">if</span>(cust.length == <span class="number">0</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">"客户列表为空！"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cust.length; i++) &#123;</span><br><span class="line">				System.out.println(i + <span class="number">1</span> + <span class="string">"\t"</span> + cust[i].getName()+ <span class="string">"\t"</span> + cust[i].getGender()+ <span class="string">"\t"</span> + cust[i].getAge()+ <span class="string">"\t"</span> + cust[i].getPhone() + <span class="string">"\t"</span> + <span class="string">"\t"</span> +cust[i].getEmail());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"-------------------------客户列表完成-------------------------"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		CustomerView cView = <span class="keyword">new</span> CustomerView();</span><br><span class="line">		cView.enterMainMenu();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h3><ul>
<li>添加客户</li>
</ul>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191220/UvKmCj6JcpKp.png" alt="mark"></p>
<ul>
<li>修改客户</li>
</ul>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191220/gKGYWGYD3UNo.png" alt="mark"></p>
<ul>
<li>删除客户</li>
</ul>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191220/JSP95pw9q2my.png" alt="mark"></p>
<ul>
<li>客户列表</li>
</ul>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191220/M8zeEb0qRsnT.png" alt="mark"></p>
<ul>
<li>退出</li>
</ul>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191220/L2GhdnbrDykV.png" alt="mark"></p>
]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据结构与算法——队列</title>
    <url>/2019/12/10/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191217/QraeaDA9hLep.jpg?imageslim" alt="mark"></p>
<a id="more"></a> 

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191216/jhIm0HhcKYbY.png?imageslim" alt="mark"></p>
<ol>
<li>队列是一个有序列表，可以用<strong>数组</strong>或是<strong>链表</strong>来实现。</li>
<li>遵循<strong>先入先出</strong>的原则。即：先存入队列的数据，要先取出。后存入的要后取出</li>
</ol>
<h2 id="数组模拟队列"><a href="#数组模拟队列" class="headerlink" title="数组模拟队列"></a>数组模拟队列</h2><p>使用数组模拟队列的方法需要两个变量front、rear分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">front = -<span class="number">1</span>; <span class="comment">// 指向队列头部，分析出front是指向队列头的前一个位置.</span></span><br><span class="line">rear = -<span class="number">1</span>; <span class="comment">// 指向队列尾，指向队列尾的数据(即就是队列最后一个数据)</span></span><br></pre></td></tr></table></figure>

<p>利用这两个变量可以进行<strong>队列空</strong>、<strong>队列满</strong>、<strong>数据入队列</strong>、<strong>数据出队列</strong>的判断。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用数组模拟队列-编写一个ArrayQueue类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">// 表示数组的最大容量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> front; <span class="comment">// 队列头</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> rear; <span class="comment">// 队列尾</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] arr; <span class="comment">// 该数据用于存放数据, 模拟队列</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建队列的构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span> </span>&#123;</span><br><span class="line">		maxSize = arrMaxSize;</span><br><span class="line">		arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">		front = -<span class="number">1</span>; <span class="comment">// 指向队列头部，分析出front是指向队列头的前一个位置.</span></span><br><span class="line">		rear = -<span class="number">1</span>; <span class="comment">// 指向队列尾，指向队列尾的数据(即就是队列最后一个数据)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断队列是否满</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rear == maxSize - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断队列是否为空</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rear == front;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加数据到队列</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断队列是否满</span></span><br><span class="line">		<span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"队列满，不能加入数据~"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		rear++; <span class="comment">// 让rear 后移</span></span><br><span class="line">		arr[rear] = n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取队列的数据, 出队列</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断队列是否空</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			<span class="comment">// 通过抛出异常</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空，不能取数据"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		front++; <span class="comment">// front后移</span></span><br><span class="line">		<span class="keyword">return</span> arr[front];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示队列的所有数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 遍历</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"arr[%d]=%d\n"</span>, i, arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示队列的头数据， 注意不是取出数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arr[front + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h2><p>对于上面方式创建的数组队列，有一个非常致命的问题，队列无法循环使用，为了解决这个问题我们引入取模操作，利用数组模拟一个环形队列，使得队列能够一直使用。</p>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191216/t221VHd7yIl6.png?imageslim" alt="mark"></p>
<p>如上图分析所示，变量front和rear需要做一个变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素 </span></span><br><span class="line"><span class="comment">//front 的初始值 = 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> front; </span><br><span class="line"><span class="comment">//rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.</span></span><br><span class="line"><span class="comment">//rear 的初始值 = 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rear; <span class="comment">// 队列尾</span></span><br></pre></td></tr></table></figure>

<p>建立循环队列的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleArray</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">// 表示数组的最大容量</span></span><br><span class="line">	<span class="comment">//front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素 </span></span><br><span class="line">	<span class="comment">//front 的初始值 = 0</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> front; </span><br><span class="line">	<span class="comment">//rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.</span></span><br><span class="line">	<span class="comment">//rear 的初始值 = 0</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> rear; <span class="comment">// 队列尾</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] arr; <span class="comment">// 该数据用于存放数据, 模拟队列</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CircleArray</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span> </span>&#123;</span><br><span class="line">		maxSize = arrMaxSize;</span><br><span class="line">		arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 判断队列是否满</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (rear  + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 判断队列是否为空</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rear == front;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 添加数据到队列</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断队列是否满</span></span><br><span class="line">		<span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"队列满，不能加入数据~"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//直接将数据加入</span></span><br><span class="line">		arr[rear] = n;</span><br><span class="line">		<span class="comment">//将 rear 后移, 这里必须考虑取模</span></span><br><span class="line">		rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取队列的数据, 出队列</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断队列是否空</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			<span class="comment">// 通过抛出异常</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空，不能取数据"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 这里需要分析出 front是指向队列的第一个元素</span></span><br><span class="line">		<span class="comment">// 1. 先把 front 对应的值保留到一个临时变量</span></span><br><span class="line">		<span class="comment">// 2. 将 front 后移, 考虑取模</span></span><br><span class="line">		<span class="comment">// 3. 将临时保存的变量返回</span></span><br><span class="line">		<span class="keyword">int</span> value = arr[front];</span><br><span class="line">		front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 显示队列的所有数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 遍历</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 思路：从front开始遍历，遍历多少个元素</span></span><br><span class="line">		<span class="comment">// 动脑筋</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; front + size() ; i++) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"arr[%d]=%d\n"</span>, i % maxSize, arr[i % maxSize]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 求出当前队列有效数据的个数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// rear = 2</span></span><br><span class="line">		<span class="comment">// front = 1</span></span><br><span class="line">		<span class="comment">// maxSize = 3 </span></span><br><span class="line">		<span class="keyword">return</span> (rear + maxSize - front) % maxSize;   </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 显示队列的头数据， 注意不是取出数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arr[front];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据结构与算法——排序</title>
    <url>/2019/12/09/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191216/H8299vPG1R1R.jpg?imageslim" alt="mark"></p>
<a id="more"></a> 

<h1 id="初级排序"><a href="#初级排序" class="headerlink" title="初级排序"></a>初级排序</h1><p>《算法（第四版）》 第二章第一节 本章主要内容是选择排序、插入排序以及shell排序。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>不断选择剩余元素中的最小者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span> <span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;  j &lt; N; j++)</span><br><span class="line">                <span class="keyword">if</span>(less(a[j], a[min]))	min = j;</span><br><span class="line">            exch(a, i, min); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)</p>
<p>运行时间与输入无关，有序数组同样需要等长时间。</p>
<p>数据的移动是最少的，N次交换——交换次数与数组长度是线性关系。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>每次都把当前值放入该值前面部分</p>
<p>插入排序时间取决于输入中元素的初始顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j],a[j-<span class="number">1</span>]); j--)</span><br><span class="line">                exch(a, j, j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>使数组中任意间隔为h的元素都是有序的。</p>
<p>通过提升速度来解决其他方式无法解决的问题是研究算法的设计和性能的主要原因之一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Shell排序算法</span></span><br><span class="line">	<span class="keyword">int</span> N = a.length;</span><br><span class="line">	<span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(h &lt; N/<span class="number">3</span>) h = <span class="number">3</span>*h + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(h &gt;= <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = h; i &lt; N; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(a[j],a[j-h]); j -= h)</span><br><span class="line">               exch(a, j, j-h);</span><br><span class="line">		&#125;</span><br><span class="line">		h = h/<span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并：将两个有序的数组归并成一个更大的有序数组。</p>
<p>优点：任意长度为N的数组排序所需时间和NlogN成正比</p>
<p>缺点：所需的额外空间和N成正比</p>
<h2 id="原地归并的抽象方法"><a href="#原地归并的抽象方法" class="headerlink" title="原地归并的抽象方法"></a>原地归并的抽象方法</h2>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识——对象和类</title>
    <url>/2019/12/09/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</url>
    <content><![CDATA[<p><img src="http://image.gwbiubiubiu.com/blog/20191216/XxQail85b7FQ.jpg?imageslim" alt="mark"> </p>
<a id="more"></a> 

<h1 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h1><p>《Java核心技术 卷I》第四章 本章主要内容是Java中对象和类的知识。</p>
<h2 id="静态与与静态方法"><a href="#静态与与静态方法" class="headerlink" title="静态与与静态方法"></a>静态与与静态方法</h2><h3 id="静态域"><a href="#静态域" class="headerlink" title="静态域"></a>静态域</h3><p>每个类中只有一个这样的域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>静态域属于类，不属于任何独立的对象。静态域其实是类域。</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>静态方法不能向对象实施操作，没有隐式的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.pow(x,a)</span><br></pre></td></tr></table></figure>

<p>静态方法不能访问实例域，不能操作对象，但是可以访问静态域。</p>
<p>建议通过类对象的引用来调用方法。</p>
<h3 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pulic <span class="class"><span class="keyword">class</span> <span class="title">Math</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.1416926</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><p>不需要使用对象调用静态方法。</p>
<h2 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h2><ul>
<li>Java程序设计语言总是采用按值调用</li>
<li>方法得到的所有参数值都是拷贝</li>
<li>方法不能修改传递给它的任何参数变量的内容</li>
</ul>
<p>对于对象引用作为参数，对象引用以及其他的拷贝同时引用同一个对象，对象引用是按值传递的。</p>
<p>总结Java中方法参数的使用情况</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数（数值型或布尔型）</li>
<li>一个方法可以改变一个对象参数的状态</li>
<li>一个方法不能让对象参数引用一个新的对象</li>
</ul>
<h2 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h2><h3 id="重载-overloading"><a href="#重载-overloading" class="headerlink" title="重载(overloading)"></a>重载(overloading)</h3><p>多个方法有相同的名字，不同的参数。</p>
<p>重载解析：编译器用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法，如果找不到，就会产生编译错误。</p>
<h3 id="默认域初始化"><a href="#默认域初始化" class="headerlink" title="默认域初始化"></a>默认域初始化</h3><p>如果不显式的给域赋初值，自动的赋为默认值，数值为0，布尔值为false，对象引用为null。</p>
<h3 id="无参数构造器"><a href="#无参数构造器" class="headerlink" title="无参数构造器"></a>无参数构造器</h3><p>编写类没有编写构造函数——》系统提供无参数构造函数</p>
<p>类中有构造器，但是无无参数构造函数——》构造对象时不提供参数被视为不合法</p>
<h3 id="调用另一个构造器"><a href="#调用另一个构造器" class="headerlink" title="调用另一个构造器"></a>调用另一个构造器</h3><p>关键词this引用方法的隐式参数</p>
<p>构造器中使用this(…)表示，构造器将调用同一个类的另一个构造器，可以用于对公共部分的构造器代码的简化。</p>
<h3 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h3><ul>
<li>在构造域中设置值</li>
<li>在声明中赋值</li>
<li>在初始化块中被初始化</li>
</ul>
<p>只要构造类对象，初始化块就被执行，先运行初始化块，再运行构造器的主体部分。</p>
<p>下面是调用构造器的具体处理步骤</p>
<ol>
<li>所有数据域被初始化为默认值（0、false、或者null）</li>
<li>按照在类的声明中出现的次序，依次执行所有域的初始化语句和初始化块</li>
<li>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体</li>
<li>执行这个构造器的主体</li>
</ol>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>使用包可以确保类名的唯一性。</p>
<p>从编译的角度看，嵌套的包之间没有任何关系。</p>
<h3 id="类的导入"><a href="#类的导入" class="headerlink" title="类的导入"></a>类的导入</h3><p>使用import语句导入一个特定的类或者整个包。</p>
<p>或者在每个类名之前添加完整包名。</p>
<h3 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br></pre></td></tr></table></figure>

<p>就可以使用System类的静态方法和静态域，不必加类名前缀。</p>
<h3 id="将类放入包中"><a href="#将类放入包中" class="headerlink" title="将类放入包中"></a>将类放入包中</h3><p>将包的名字放在源文件的开头，包中定义类的代码之前。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.horstman.corejava</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果没有package语句，那么类被放置在默认包(default package)中。</p>
<h2 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h2><p>类存储在文件系统子目录中，类的路径必须与包名匹配。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
