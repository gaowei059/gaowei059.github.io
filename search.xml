<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java基础知识——异常处理</title>
    <url>/2019/12/24/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191224/cKrbT5eichum.jpg" alt="mark"></p>
<a id="more"></a>

<h2 id="Java基础知识——异常处理"><a href="#Java基础知识——异常处理" class="headerlink" title="Java基础知识——异常处理"></a>Java基础知识——异常处理</h2><h3 id="1-异常概述与异常体系结构"><a href="#1-异常概述与异常体系结构" class="headerlink" title="1. 异常概述与异常体系结构"></a>1. 异常概述与异常体系结构</h3><ul>
<li><p>异常：在Java语言中，将程序执行中发生的不正常情况称为“异常” 。 (开发过程中的语法错误和逻辑错误不是异常)</p>
</li>
<li><p>Java程序在执行过程中所发生的异常事件可分为两类：</p>
<ul>
<li><p>Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源 耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性 的代码进行处理。</p>
</li>
<li><p>Exception: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使 用针对性的代码进行处理。例如：</p>
<p><strong>空指针访问</strong> </p>
<p><strong>试图读取不存在的文件</strong> </p>
<p><strong>网络连接中断</strong></p>
<p><strong>数组角标越界</strong></p>
</li>
</ul>
</li>
</ul>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191224/bLT684OP0eJG.png" alt="mark"><br><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191224/Y3gdDx15hqaP.png" alt="mark"></p>
<h3 id="2-常见异常"><a href="#2-常见异常" class="headerlink" title="2. 常见异常"></a>2. 常见异常</h3><h3 id="3-异常处理机制一：try–catch–finally"><a href="#3-异常处理机制一：try–catch–finally" class="headerlink" title="3. 异常处理机制一：try–catch–finally"></a>3. 异常处理机制一：try–catch–finally</h3><h4 id="异常的处理：抓抛模型"><a href="#异常的处理：抓抛模型" class="headerlink" title="异常的处理：抓抛模型"></a>异常的处理：抓抛模型</h4><ul>
<li><p>过程一：”抛”：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。并将此对象抛出。一旦抛出对象以后，其后的代码就不再执行。</p>
<p>关于异常对象的产生：</p>
<p>① 系统自动生成的异常对象</p>
<p>② 手动的生成一个异常对象，并抛出（throw）</p>
</li>
<li><p>过程二：”抓”：可以理解为异常的处理方式：① try-catch-finally  ② throws</p>
</li>
</ul>
<h4 id="try-catch-finally的使用"><a href="#try-catch-finally的使用" class="headerlink" title="try-catch-finally的使用"></a>try-catch-finally的使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"> 		<span class="comment">//可能出现异常的代码</span></span><br><span class="line"> </span><br><span class="line"> &#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line"> 		<span class="comment">//处理异常的方式1</span></span><br><span class="line"> &#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line"> 		<span class="comment">//处理异常的方式2</span></span><br><span class="line"> &#125;<span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>)&#123;</span><br><span class="line"> 		<span class="comment">//处理异常的方式3</span></span><br><span class="line"> &#125;</span><br><span class="line"> ....</span><br><span class="line"> <span class="keyword">finally</span>&#123;</span><br><span class="line"> 		<span class="comment">//一定会执行的代码</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li><p>finally是可选的。</p>
</li>
<li><p>使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象</p>
</li>
</ol>
<p>的类型，去catch中进行匹配</p>
<ol start="3">
<li>一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的</li>
</ol>
<p>try-catch结构（在没有写finally的情况）。继续执行其后的代码</p>
<ol start="4">
<li>catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓。</li>
</ol>
<p>catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错</p>
<ol start="5">
<li><p>常用的异常对象处理的方式： ① String  getMessage()    ② printStackTrace()</p>
</li>
<li><p>在try结构中声明的变量，再出了try结构以后，就不能再被调用</p>
</li>
<li><p>try-catch-finally结构可以嵌套</p>
</li>
</ol>
<p>体会1：使用try-catch-finally处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。</p>
<p>体会2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。针对于编译时异常，我们说一定要考虑异常的处理。</p>
<h4 id="try-catch-finally中finally的使用："><a href="#try-catch-finally中finally的使用：" class="headerlink" title="try-catch-finally中finally的使用："></a>try-catch-finally中finally的使用：</h4><ol>
<li><p>finally是可选的</p>
</li>
<li><p>finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中有return语句，catch中有return语句等情况。</p>
</li>
<li><p>像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。</p>
</li>
</ol>
<h3 id="4-异常处理机制二：throws"><a href="#4-异常处理机制二：throws" class="headerlink" title="4. 异常处理机制二：throws"></a>4. 异常处理机制二：throws</h3><ol>
<li><p>“throws + 异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！</p>
</li>
<li><p>体会：try-catch-finally:真正的将异常给处理掉了。throws的方式只是将异常抛给了方法的调用者。  并没有真正将异常处理掉。  </p>
</li>
<li><p>开发中如何选择使用try-catch-finally 还是使用throws？</p>
</li>
</ol>
<ul>
<li><p>如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理。</p>
</li>
<li><p>执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理。</p>
</li>
</ul>
<h3 id="5-手动抛出异常：throw"><a href="#5-手动抛出异常：throw" class="headerlink" title="5. 手动抛出异常：throw"></a>5. 手动抛出异常：throw</h3><p>Java异常类对象除在程序执行过程中出现异常时由系统自动生成并 抛出，也可根据需要使用人工创建并抛出。 </p>
<ul>
<li><p>首先要生成异常类对象，然后通过throw语句实现抛出操作(提交给Java运 行环境)。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IOException e = <span class="keyword">new</span> IOException(); </span><br><span class="line"><span class="keyword">throw</span> e;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以抛出的异常必须是Throwable或其子类的实例。下面的语句在编译时将 会产生语法错误： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> String(<span class="string">"want to throw"</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="6-用户自定义异常"><a href="#6-用户自定义异常" class="headerlink" title="6. 用户自定义异常"></a>6. 用户自定义异常</h3><p>如何自定义异常类？</p>
<ul>
<li>继承于现有的异常结构：RuntimeException 、Exception</li>
<li>提供全局常量：serialVersionUID</li>
<li>提供重载的构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EcDef</span>  <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">33875164229948L</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">EcDef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">EcDef</span> <span class="params">(String message)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(message);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识——抽象和接口</title>
    <url>/2019/12/21/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191221/DAppFmUfqzKl.jpg" alt="mark"></p>
<a id="more"></a>

<h1 id="Java基础知识——抽象和接口"><a href="#Java基础知识——抽象和接口" class="headerlink" title="Java基础知识——抽象和接口"></a>Java基础知识——抽象和接口</h1><h2 id="抽象：abstract"><a href="#抽象：abstract" class="headerlink" title="抽象：abstract"></a>抽象：abstract</h2><h3 id="abstract关键字的使用"><a href="#abstract关键字的使用" class="headerlink" title="abstract关键字的使用"></a>abstract关键字的使用</h3><ol>
<li>abstract:抽象的</li>
</ol>
<ol start="2">
<li>abstract可以用来修饰的结构：类、方法</li>
</ol>
<ol start="3">
<li>abstract修饰类：抽象类</li>
</ol>
<blockquote>
<p>此类不能实例化</p>
<p>抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）</p>
<p>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作</p>
</blockquote>
<ol start="4">
<li>abstract修饰方法：抽象方法</li>
</ol>
<blockquote>
<p>抽象方法只有方法的声明，没有方法体</p>
<p>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。</p>
<p>若子类重写了父类中的所有的抽象方法后，此子类方可实例化</p>
</blockquote>
<p>若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</p>
<h3 id="abstract使用上的注意点"><a href="#abstract使用上的注意点" class="headerlink" title="abstract使用上的注意点"></a>abstract使用上的注意点</h3><p>abstract不能用来修饰：属性、构造器等结构</p>
<p>abstract不能用来修饰私有方法、静态方法、final的方法、final的类</p>
<h2 id="接口：interface"><a href="#接口：interface" class="headerlink" title="接口：interface"></a>接口：interface</h2><p>接口的使用</p>
<p>1.接口使用interface来定义</p>
<p>2.Java中，接口和类是并列的两个结构</p>
<p>3.如何定义接口：定义接口中的成员</p>
<ul>
<li>JDK7及以前：只能定义全局常量和抽象方法</li>
</ul>
<blockquote>
<p>全局常量：public static final的.但是书写时，可以省略不写</p>
<p>抽象方法：public abstract的</p>
</blockquote>
<ul>
<li>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</li>
</ul>
<blockquote>
<p>知识点1：接口中定义的静态方法，只能通过接口来调用。</p>
<p>知识点2：通过实现类的对象，可以调用接口中的默认方法。</p>
<p>如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法<br>知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，</p>
<p>那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。–&gt;类优先原则</p>
<p>知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，</p>
<p>那么在实现类没有重写此方法的情况下，报错。–&gt;接口冲突。</p>
<p>这就需要我们必须在实现类中重写此方法</p>
</blockquote>
<ol start="4">
<li><p>接口中不能定义构造器的！意味着接口不可以实例化</p>
</li>
<li><p>Java开发中，接口通过让类去实现(implements)的方式来使用.</p>
</li>
</ol>
<blockquote>
<p>如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化</p>
<p>如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类</p>
</blockquote>
<ol start="6">
<li>Java类可以实现多个接口   —&gt;弥补了Java单继承性的局限性</li>
</ol>
<blockquote>
<p>格式：class AA extends BB implements CC,DD,EE</p>
</blockquote>
<ol start="7">
<li><p>接口与接口之间可以继承，而且可以多继承</p>
</li>
<li><p>接口的具体使用，体现多态性</p>
</li>
<li><p>接口，实际上可以看做是一种规范</p>
</li>
</ol>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ol>
<li><p>Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类</p>
</li>
<li><p>内部类的分类：成员内部类（静态、非静态）  vs 局部内部类(方法内、代码块内、构造器内)</p>
</li>
<li><p>成员内部类：</p>
</li>
</ol>
<ul>
<li>一方面，作为外部类的成员：</li>
</ul>
<blockquote>
<p>调用外部类的结构</p>
<p>可以被static修饰</p>
<p>可以被4种不同的权限修饰</p>
</blockquote>
<ul>
<li>另一方面，作为一个类：</li>
</ul>
<blockquote>
<p>类内可以定义属性、方法、构造器等</p>
<p>可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承</p>
<p>可以被abstract修饰</p>
</blockquote>
<ol start="4">
<li>关注如下的3个问题</li>
</ol>
<ul>
<li><p>如何实例化成员内部类的对象</p>
</li>
<li><p>如何在成员内部类中区分调用外部类的结构</p>
</li>
<li><p>开发中局部内部类的使用  见《InnerClassTest1.java》</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest1</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//开发中很少见</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//局部内部类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//返回一个实现了Comparable接口的类的对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Comparable <span class="title">getComparable</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建一个实现了Comparable接口的类:局部内部类</span></span><br><span class="line">		<span class="comment">//方式一：</span></span><br><span class="line"><span class="comment">//		class MyComparable implements Comparable&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//			@Override</span></span><br><span class="line"><span class="comment">//			public int compareTo(Object o) &#123;</span></span><br><span class="line"><span class="comment">//				return 0;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//			</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		return new MyComparable();</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//方式二：</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Comparable()&#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据结构与算法——约瑟夫问题</title>
    <url>/2019/12/20/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191220/rW7Lvs3umTPq.jpg" alt="mark"></p>
<a id="more"></a>

<h2 id="Java数据结构与算法——约瑟夫问题"><a href="#Java数据结构与算法——约瑟夫问题" class="headerlink" title="Java数据结构与算法——约瑟夫问题"></a>Java数据结构与算法——约瑟夫问题</h2><p>Josephu 问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k (1&lt;=k&lt;=n)的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p>
<h4 id="问题思路"><a href="#问题思路" class="headerlink" title="问题思路"></a>问题思路</h4><p>用一个不带头结点的循环链表来处理Josephu 问题：先构成一个有n个结点的单循环链表，然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。</p>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191220/lMP5UPoTwgn6.png" alt="mark"></p>
<h4 id="构建一个单向的环形链表思路"><a href="#构建一个单向的环形链表思路" class="headerlink" title="构建一个单向的环形链表思路"></a>构建一个单向的环形链表思路</h4><p>先创建第一个节点, 让 first 指向该节点，并形成环形，后面当我们每创建一个新的节点，就把该节点，加入到已有的环形链表中即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加小孩节点，构建成一个环形的链表</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBoy</span><span class="params">(<span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (nums &lt; <span class="number">1</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"nums的值不正确"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Boy curBoy = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line">			Boy newBoy = <span class="keyword">new</span> Boy(i);</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">				first = newBoy;</span><br><span class="line">				first.setNext(first);</span><br><span class="line">				curBoy = first;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				curBoy.setNext(newBoy);</span><br><span class="line">				newBoy.setNext(first);</span><br><span class="line">				curBoy = curBoy.getNext();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h4 id="遍历环形链表"><a href="#遍历环形链表" class="headerlink" title="遍历环形链表"></a>遍历环形链表</h4><p>先让一个辅助指针(变量) curBoy，指向first节点，然后通过一个while循环遍历 该环形链表即可 curBoy.next == first 结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历当前的环形链表</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBoy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断链表是否为空</span></span><br><span class="line">		<span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"没有任何小孩~~"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 因为first不能动，因此我们仍然使用一个辅助指针完成遍历</span></span><br><span class="line">		Boy curBoy = first;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"小孩的编号 %d \n"</span>, curBoy.getNo());</span><br><span class="line">			<span class="keyword">if</span> (curBoy.getNext() == first) &#123;<span class="comment">// 说明已经遍历完毕</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			curBoy = curBoy.getNext(); <span class="comment">// curBoy后移</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h4 id="根据用户的输入，生成一个小孩出圈的顺序"><a href="#根据用户的输入，生成一个小孩出圈的顺序" class="headerlink" title="根据用户的输入，生成一个小孩出圈的顺序"></a>根据用户的输入，生成一个小孩出圈的顺序</h4><ul>
<li><p>n = 5 , 即有5个人</p>
</li>
<li><p>k = 1, 从第一个人开始报数</p>
</li>
<li><p>m = 2, 数2下</p>
</li>
</ul>
<p>需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点.</p>
<p>补充： 小孩报数前，先让 first 和 helper 移动 k - 1次</p>
<p>当小孩报数时，让first 和 helper 指针同时 的移动 m - 1 次</p>
<p>这时就可以将first 指向的小孩节点 出圈</p>
<p>first = first .next </p>
<p>helper.next = first </p>
<p>原来first 指向的节点就没有任何引用，就会被回收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据用户的输入，计算出小孩出圈的顺序</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> startNo  表示从第几个小孩开始数数</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> countNum 表示数几下</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> nums     表示最初有多少小孩在圈中</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countBoy</span><span class="params">(<span class="keyword">int</span> startNo, <span class="keyword">int</span> countNum, <span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 先对数据进行校验</span></span><br><span class="line">		<span class="keyword">if</span> (first == <span class="keyword">null</span> || startNo &gt; nums || startNo &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"WRONG INPUT!!!!"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Boy helper = first;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (helper.getNext() == first) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			helper = helper.getNext();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; startNo - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			helper = helper.getNext();</span><br><span class="line">			first = first.getNext();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (first.getNext() == first) &#123;</span><br><span class="line">				System.out.println(<span class="string">"最后留下的小孩是"</span> + first.getNo());</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; countNum - <span class="number">1</span>; i++) &#123;</span><br><span class="line">				first = first.getNext();</span><br><span class="line">				helper = helper.getNext();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(first.getNo() + <span class="string">"号小孩出圈~~~~"</span>);</span><br><span class="line">			helper.setNext(first.getNext());</span><br><span class="line">			first = first.getNext();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>出圈的顺序</p>
<p>2-&gt;4-&gt;1-&gt;5-&gt;3 </p>
<p>结果：</p>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191221/MyfIhFFDqaKi.png" alt="mark"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据结构与算法——链表</title>
    <url>/2019/12/19/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191219/QXv92AYeSPvA.jpg" alt="mark" style="zoom:200%;" />

<a id="more"></a>

<h2 id="Java数据结构与算法——链表"><a href="#Java数据结构与算法——链表" class="headerlink" title="Java数据结构与算法——链表"></a>Java数据结构与算法——链表</h2><p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191219/8utgPE1PonQ3.png" alt="mark"></p>
<ul>
<li>链表是以节点的方式来存储,是链式存储</li>
<li>每个节点包含 data 域， next 域：指向下一个节点.</li>
<li>发现链表的<strong>各个节点不一定是连续存储</strong>.</li>
<li>链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定</li>
</ul>
<h3 id="1-单链表"><a href="#1-单链表" class="headerlink" title="1. 单链表"></a>1. 单链表</h3><h4 id="1-1-单链表的基本操作"><a href="#1-1-单链表的基本操作" class="headerlink" title="1.1 单链表的基本操作"></a>1.1 单链表的基本操作</h4><p>单链表(带头结点) 逻辑结构示意图如下：</p>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191219/wyctOYDNq0A5.png" alt="mark"></p>
<h5 id="1-1-1-增加节点"><a href="#1-1-1-增加节点" class="headerlink" title="1.1.1 增加节点"></a>1.1.1 增加节点</h5><p><strong>在末尾添加</strong></p>
<p>思路：遍历链表，当遍历到链表末尾时（temp.next == null），插入节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加节点到单向链表</span></span><br><span class="line"><span class="comment">// 思路，当不考虑编号顺序时</span></span><br><span class="line"><span class="comment">// 1. 找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">// 2. 将最后这个节点的next 指向 新的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(LinkedNode heroNode)</span> </span>&#123;</span><br><span class="line">	LinkedNode temp;</span><br><span class="line">	temp = getHead();</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			temp.next = heroNode;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp.next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>按顺序添加</strong></p>
<p>思路：遍历链表，当遍历到的节点的下一个节点的序号大于插入节点的序号，退出循环，插入节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line"><span class="comment">// (如果有这个排名，则添加失败，并给出提示)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(LinkedNode heroNode)</span> </span>&#123;</span><br><span class="line">	LinkedNode temp = getHead();</span><br><span class="line">	<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			temp.next = heroNode;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"存在%d号成员，无法添加\n"</span>, heroNode.no);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;</span><br><span class="line">			flag = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp.next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		heroNode.next = temp.next;</span><br><span class="line">		temp.next = heroNode;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-2-删除节点"><a href="#1-1-2-删除节点" class="headerlink" title="1.1.2 删除节点"></a>1.1.2 删除节点</h5><p>思路：</p>
<ol>
<li>先判断链表是否为空，若为空，直接删除失败；</li>
<li>遍历链表，找到要删除的节点的前一个节点；</li>
<li>将要删除的节点的前一个节点指向要删除的节点的下一个节点；</li>
<li>如果找不到要删除的节点，返回删除失败。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="comment">// 思路</span></span><br><span class="line"><span class="comment">// 1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span></span><br><span class="line"><span class="comment">// 2. 说明我们在比较时，是temp.next.no 和 需要删除的节点的no比较</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">		System.out.println(<span class="string">"链表为空~"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedNode temp = getHead();</span><br><span class="line">	<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">			flag = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp.next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// System.out.println("没有找到" + no + "号节点，无法修改！");</span></span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		temp.next = temp.next.next;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">"没有找到"</span> + no + <span class="string">"号节点，无法修改！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-3-修改节点"><a href="#1-1-3-修改节点" class="headerlink" title="1.1.3 修改节点"></a>1.1.3 修改节点</h5><p>思路：</p>
<ol>
<li><p>先判断链表是否为空，若为空，直接修改失败；</p>
<ol start="2">
<li>遍历链表，找到要修改的节点；</li>
<li>修改节点内容；</li>
<li>如果找不到要修改的节点，返回修改失败。</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改节点的信息, 根据no编号来修改，即no编号不能改.</span></span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 1. 根据 newHeroNode 的 no 来修改即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(LinkedNode newHeroNode)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">		System.out.println(<span class="string">"链表为空~"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedNode temp = getHead();</span><br><span class="line">	<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (temp.next.no == newHeroNode.no) &#123;</span><br><span class="line">			newHeroNode.next = temp.next.next;</span><br><span class="line">			temp.next = newHeroNode;</span><br><span class="line">			flag = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp.next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	System.out.println(<span class="string">"没有找到"</span> + newHeroNode.no + <span class="string">"号节点，无法修改！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1-2-单链表的几个面试题"><a href="#1-2-单链表的几个面试题" class="headerlink" title="1.2 单链表的几个面试题"></a>1.2 单链表的几个面试题</h4><h5 id="1-2-1-求单链表中有效节点的个数"><a href="#1-2-1-求单链表中有效节点的个数" class="headerlink" title="1.2.1 求单链表中有效节点的个数"></a>1.2.1 求单链表中有效节点的个数</h5><p>思路：遍历链表，找到一个节点就让计数器加1，直到遍历到链表尾。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(LinkedNode head)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">		LinkedNode temp = head.next;</span><br><span class="line">		<span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">			length++;</span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> length;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-2-查找单链表中的倒数第k个结点"><a href="#1-2-2-查找单链表中的倒数第k个结点" class="headerlink" title="1.2.2 查找单链表中的倒数第k个结点"></a>1.2.2 查找单链表中的倒数第k个结点</h5><p>思路：</p>
<ol>
<li>编写一个方法，接收head节点，同时接收一个index</li>
<li>index 表示是倒数第index个节点</li>
<li>先把链表从头到尾遍历，得到链表的总的长度 getLength</li>
<li>得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到</li>
<li>如果找到了，则返回该节点，否则返回null</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找单链表中的倒数第k个结点 【新浪面试题】</span></span><br><span class="line"><span class="comment">// 思路</span></span><br><span class="line"><span class="comment">// 1. 编写一个方法，接收head节点，同时接收一个index</span></span><br><span class="line"><span class="comment">// 2. index 表示是倒数第index个节点</span></span><br><span class="line"><span class="comment">// 3. 先把链表从头到尾遍历，得到链表的总的长度 getLength</span></span><br><span class="line"><span class="comment">// 4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到</span></span><br><span class="line"><span class="comment">// 5. 如果找到了，则返回该节点，否则返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LinkedNode <span class="title">findLastIndexNode</span><span class="params">(LinkedNode head, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> length = SingleLinkedList.getLength(head);</span><br><span class="line">	<span class="keyword">if</span> (index &lt;= <span class="number">0</span> || index &gt; length) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedNode temp = head.next;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - index; i++) &#123;</span><br><span class="line">		temp = temp.next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-3-单链表的反转"><a href="#1-2-3-单链表的反转" class="headerlink" title="1.2.3 单链表的反转"></a>1.2.3 单链表的反转</h5><p>方式1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反转链表方式1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversetList</span><span class="params">(LinkedNode head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedNode temp = head;</span><br><span class="line">	LinkedNode reverseNode = <span class="keyword">new</span> LinkedNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">	LinkedNode reTEMP = reverseNode;</span><br><span class="line">	<span class="keyword">while</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">		temp = head;</span><br><span class="line">		<span class="keyword">while</span> (temp.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		reTEMP.next = temp.next;</span><br><span class="line">		reTEMP = reTEMP.next;</span><br><span class="line">		temp.next = <span class="keyword">null</span>;</span><br><span class="line">		<span class="comment">// break;</span></span><br><span class="line">	&#125;</span><br><span class="line">	head.next = reverseNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">revList</span><span class="params">(LinkedNode head)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 如果链表为空或只含有一个节点，直接返回</span></span><br><span class="line">  	<span class="keyword">if</span> (head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">  			<span class="keyword">return</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	LinkedNode cur = head.next;</span><br><span class="line">  	LinkedNode next;</span><br><span class="line">  	LinkedNode revhead = <span class="keyword">new</span> LinkedNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line">  	<span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">  		next = cur.next;</span><br><span class="line">  		cur.next = revhead.next;</span><br><span class="line">  		revhead.next = cur;</span><br><span class="line">  		cur = next;</span><br><span class="line">  		&#125;</span><br><span class="line">  	head.next = revhead.next;</span><br><span class="line">  	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-4-从尾到头打印单链表"><a href="#1-2-4-从尾到头打印单链表" class="headerlink" title="1.2.4 从尾到头打印单链表"></a>1.2.4 从尾到头打印单链表</h5><p>方式1：反向遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式1：</span></span><br><span class="line"><span class="comment">// 方向遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">revPrint</span><span class="params">(LinkedNode head)</span> </span>&#123;</span><br><span class="line">  	SingleLinkedList s1 = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">  	s1.head.next = head.next;</span><br><span class="line">  	<span class="keyword">int</span> length = SingleLinkedList.getLength(head);</span><br><span class="line">  	<span class="keyword">for</span>(<span class="keyword">int</span> i = length; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">  		System.out.println(s1.getNode(i));</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方式2：Stack栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式2：</span></span><br><span class="line"><span class="comment">// 可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">(LinkedNode head)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">  		<span class="keyword">return</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	Stack&lt;LinkedNode&gt; stack = <span class="keyword">new</span> Stack&lt;LinkedNode&gt;();</span><br><span class="line">  	LinkedNode temp = head.next;</span><br><span class="line">  	<span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">  		stack.add(temp);</span><br><span class="line">  		temp = temp.next;</span><br><span class="line">  	&#125;</span><br><span class="line"> 	<span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  		System.out.println(stack.pop());</span><br><span class="line">  	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-2-5-合并两个有序的单链表，合并之后的链表依然有序"><a href="#1-2-5-合并两个有序的单链表，合并之后的链表依然有序" class="headerlink" title="1.2.5 合并两个有序的单链表，合并之后的链表依然有序"></a>1.2.5 合并两个有序的单链表，合并之后的链表依然有序</h5><p>思路：遍历链表2，每找到一个节点就将其按顺序插入链表1，直到链表2为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 合并两个有序的单链表，合并之后的链表依然有序</span></span><br><span class="line"><span class="comment">// 合并后的链表头节点为head1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeList</span><span class="params">(LinkedNode head1, LinkedNode head2)</span> </span>&#123;</span><br><span class="line">	SingleLinkedList s1 = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">	SingleLinkedList s2 = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">	s1.head.next = head1.next;</span><br><span class="line">	s2.head.next = head2.next;</span><br><span class="line">	<span class="keyword">if</span> (s1.head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">		s1.head.next = s2.head.next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (s2.head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LinkedNode temp = s2.head.next;</span><br><span class="line">	LinkedNode next = temp.next;</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		next = temp.next;</span><br><span class="line">		s1.addByOrder(temp);</span><br><span class="line">		temp = next;</span><br><span class="line">	&#125;</span><br><span class="line">	head1.next = s1.head.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-双向链表"><a href="#2-双向链表" class="headerlink" title="2. 双向链表"></a>2. 双向链表</h3><h4 id="2-1-单向链表的缺点分析"><a href="#2-1-单向链表的缺点分析" class="headerlink" title="2.1 单向链表的缺点分析"></a>2.1 单向链表的缺点分析</h4><ul>
<li>单向链表，<strong>查找的方向只能是一个方向</strong>，而双向链表可以向前或者向后查找。</li>
<li>单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以<strong>自我删除</strong>，所以前面我们单链表删除时节点，总是找到temp,temp是待删除节点的前一个节点(认真体会).</li>
<li>示意图帮助理解删除 </li>
</ul>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191220/sSw2y0SsEwzo.png" alt="mark"></p>
<h4 id="2-2-双向链表的基本操作"><a href="#2-2-双向链表的基本操作" class="headerlink" title="2.2 双向链表的基本操作"></a>2.2 双向链表的基本操作</h4><h5 id="2-2-1-遍历"><a href="#2-2-1-遍历" class="headerlink" title="2.2.1 遍历"></a>2.2.1 遍历</h5><p>方法和单链表一样只是可以向前，也可以向后查找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示链表[遍历]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Node temp;</span><br><span class="line">	temp = head;</span><br><span class="line">	<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">		System.out.println(<span class="string">"队列为空"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp.next;</span><br><span class="line">		System.out.println(temp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-2-2-添加"><a href="#2-2-2-添加" class="headerlink" title="2.2.2 添加"></a>2.2.2 添加</h5><ul>
<li><p>默认添加到双向链表的最后</p>
<p>遍历双向链表，找到最后这个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">temp.next = newNode;</span><br><span class="line">newNode.pre = temp;<span class="comment">//比单链表多一步</span></span><br></pre></td></tr></table></figure>

<p>具体代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增加节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		Node temp = head;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				temp.next = node;</span><br><span class="line">				node.pre = temp;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>按顺序添加</p>
<p>按照单链表的顺序添加，稍作修改即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按顺序增加节点</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">		Node temp = head;</span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="comment">//flag = true;</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp.next.no == node.no) &#123;</span><br><span class="line">				System.out.printf(<span class="string">"%d号节点存在，无法添加！\n"</span>,node.no);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(temp.next.no &gt; node.no) &#123;</span><br><span class="line">				flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			temp = temp.next;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag) &#123;</span><br><span class="line">			temp.next.pre = node;</span><br><span class="line">			node.next = temp.next;</span><br><span class="line">			node.pre = temp;</span><br><span class="line">			temp.next = node;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			node.pre = temp;</span><br><span class="line">			temp.next = node;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h5 id="2-2-3-修改"><a href="#2-2-3-修改" class="headerlink" title="2.2.3 修改"></a>2.2.3 修改</h5><p>思路和单链表一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Node newNode)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">		System.out.println(<span class="string">"链表为空，无法修改！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Node temp = head.next;</span><br><span class="line">	<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (temp.no == newNode.no) &#123;</span><br><span class="line">			flag = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp.next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		temp.name = newNode.name;</span><br><span class="line">		temp.nickname = newNode.nickname;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		System.out.printf(<span class="string">"没有找到%d号，无法修改！\n"</span>, newNode.no);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-2-4-删除"><a href="#2-2-4-删除" class="headerlink" title="2.2.4 删除"></a>2.2.4 删除</h5><p>双向链表可以实现自我删除，直接找打要删除的节点，不用像单链表一样找前一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">temp.pre.next = temp.next;</span><br><span class="line">temp.next.pre = temp.pre;<span class="comment">//这里可以把a = b读作把节点a指向节点b</span></span><br></pre></td></tr></table></figure>

<p>这里还要注意一点，当要删除的节点是链表最后一个节点时，不需要进行上述第二部操作，注意判别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">		System.out.println(<span class="string">"链表为空，无法删除！"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Node temp = head.next;</span><br><span class="line">	<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (temp.no == index) &#123;</span><br><span class="line">			flag = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		temp = temp.next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">		temp.pre.next = temp.next;</span><br><span class="line">		<span class="keyword">if</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">			temp.next.pre = temp.pre;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		System.out.printf(<span class="string">"没有找到%d号，无法删除！\n"</span>, index);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令大全</title>
    <url>/2019/12/17/Linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191217/eiwfh4t4HxYl.jpg?imageslim" alt="mark" style="zoom:150%;" />

]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ecilpse快捷键大全</title>
    <url>/2019/12/17/Ecilpse%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191218/2xVBxhp3kcwK.jpg" alt="mark"></p>
<a id="more"></a>

<h3 id="Eclipse中的快捷键"><a href="#Eclipse中的快捷键" class="headerlink" title="Eclipse中的快捷键"></a>Eclipse中的快捷键</h3><ol>
<li><p>补全代码的声明：alt + /</p>
</li>
<li><p>快速修复: ctrl + 1  </p>
</li>
<li><p>批量导包：ctrl + shift + o</p>
</li>
<li><p>使用单行注释：ctrl + /</p>
</li>
<li><p>使用多行注释： ctrl + shift + /   </p>
</li>
<li><p>取消多行注释：ctrl + shift + \</p>
</li>
<li><p>复制指定行的代码：ctrl + alt + down 或 ctrl + alt + up</p>
</li>
<li><p>删除指定行的代码：ctrl + d</p>
</li>
<li><p>上下移动代码：alt + up  或 alt + down</p>
</li>
<li><p>切换到下一行代码空位：shift + enter</p>
</li>
<li><p>切换到上一行代码空位：ctrl + shift + enter</p>
</li>
<li><p>如何查看源码：ctrl + 选中指定的结构   或  ctrl + shift + t</p>
</li>
<li><p>退回到前一个编辑的页面：alt + left </p>
</li>
<li><p>进入到下一个编辑的页面(针对于上面那条来说的)：alt + right</p>
</li>
<li><p>光标选中指定的类，查看继承树结构：ctrl + t</p>
</li>
<li><p>复制代码： ctrl + c</p>
</li>
<li><p>撤销： ctrl + z</p>
</li>
<li><p>反撤销： ctrl + y</p>
</li>
<li><p>剪切：ctrl + x </p>
</li>
<li><p>粘贴：ctrl + v</p>
</li>
<li><p>保存： ctrl + s</p>
</li>
<li><p>全选：ctrl + a</p>
</li>
<li><p>格式化代码： ctrl + shift + f</p>
</li>
<li><p>选中数行，整体往后移动：tab</p>
</li>
<li><p>选中数行，整体往前移动：shift + tab</p>
</li>
<li><p>在当前类中，显示类结构，并支持搜索指定的方法、属性等：ctrl + o</p>
</li>
<li><p>批量修改指定的变量名、方法名、类名等：alt + shift + r</p>
</li>
<li><p>选中的结构的大小写的切换：变成大写： ctrl + shift + x</p>
</li>
<li><p>选中的结构的大小写的切换：变成小写：ctrl + shift + y</p>
</li>
<li><p>调出生成getter/setter/构造器等结构： alt + shift + s</p>
</li>
<li><p>显示当前选择资源(工程 or 文件)的属性：alt + enter</p>
</li>
<li><p>快速查找：参照选中的Word快速定位到下一个 ：ctrl + k</p>
</li>
<li><p>关闭当前窗口：ctrl + w</p>
</li>
<li><p>关闭所有的窗口：ctrl + shift + w</p>
</li>
<li><p>查看指定的结构使用过的地方：ctrl + alt + g</p>
</li>
<li><p>查找与替换：ctrl + f</p>
</li>
<li><p>最大化当前的View：ctrl + m</p>
</li>
<li><p>直接定位到当前行的首位：home</p>
</li>
<li><p>直接定位到当前行的末位：end</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Eclipse</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法总结</title>
    <url>/2019/12/17/Markdown%E4%BD%BF%E7%94%A8%E8%AF%AD%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191217/wEYEHBJMNkFg.jpg?imageslim" alt="mark" style="zoom:150%;" />

<a id="more"></a>

<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
<p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p>
<p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>
<p>Markdown 编写的文档后缀为 <strong>.md</strong>, <strong>.markdown</strong>。</p>
<h3 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h3><h4 id="使用-号标记"><a href="#使用-号标记" class="headerlink" title="使用 # 号标记"></a>使用 # 号标记</h4><p>使用<kbd> #</kbd> 号可表示 1-6 级标题，一级标题对应一个<kbd> #</kbd> 号，二级标题对应两个<kbd> #</kbd> 号，以此类推。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"><span class="section">#### 四级标题</span></span><br><span class="line"><span class="section">##### 五级标题</span></span><br><span class="line"><span class="section">###### 六级标题</span></span><br></pre></td></tr></table></figure>

<h4 id="使用-和-标记一级和二级标题"><a href="#使用-和-标记一级和二级标题" class="headerlink" title="使用 = 和 - 标记一级和二级标题"></a>使用 = 和 - 标记一级和二级标题</h4><p>= 和 - 标记语法格式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">我展示的是一级标题</span><br><span class="line">=================</span><br><span class="line"></span><br><span class="line">我展示的是二级标题</span><br><span class="line">-----------------</span><br></pre></td></tr></table></figure>

<h3 id="Markdown-段落"><a href="#Markdown-段落" class="headerlink" title="Markdown 段落"></a>Markdown 段落</h3><p>Markdown 段落没有特殊的格式，直接编写文字就好，<strong>段落的换行是使用两个以上空格加上回车</strong>。</p>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>Markdown 可以使用以下几种字体：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="emphasis">*斜体文本*</span></span><br><span class="line"><span class="emphasis">_斜体文本_</span></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line"><span class="strong">__粗体文本__</span></span><br><span class="line"><span class="strong">***粗斜体文本**</span>*</span><br><span class="line"><span class="strong">___粗斜体文本__</span>_</span><br></pre></td></tr></table></figure>

<h3 id="Markdown-列表"><a href="#Markdown-列表" class="headerlink" title="Markdown 列表"></a>Markdown 列表</h3><p>Markdown 支持有序列表和无序列表。</p>
<p>无序列表使用星号(<strong>***)、加号(</strong>+<strong>)或是减号(</strong>-**)作为列表标记：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">* </span>第一项</span><br><span class="line"><span class="bullet">* </span>第二项</span><br><span class="line"><span class="bullet">* </span>第三项</span><br><span class="line"></span><br><span class="line"><span class="bullet">+ </span>第一项</span><br><span class="line"><span class="bullet">+ </span>第二项</span><br><span class="line"><span class="bullet">+ </span>第三项</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>第一项</span><br><span class="line"><span class="bullet">- </span>第二项</span><br><span class="line"><span class="bullet">- </span>第三项</span><br></pre></td></tr></table></figure>

<p>有序列表使用数字并加上 <strong>.</strong> 号来表示，如</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>第一项</span><br><span class="line"><span class="bullet">2. </span>第二项</span><br><span class="line"><span class="bullet">3. </span>第三项</span><br></pre></td></tr></table></figure>

<p>列表嵌套只需在子列表中的选项添加四个空格即可：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>第一项：</span><br><span class="line"><span class="bullet">    - </span>第一项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    - </span>第一项嵌套的第二个元素</span><br><span class="line"><span class="bullet">2. </span>第二项：</span><br><span class="line"><span class="bullet">    - </span>第二项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    - </span>第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure>

<h3 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h3><p>Markdown 区块引用是在段落开头使用 <strong>&gt;</strong> 符号 ，然后后面紧跟一个<strong>空格</strong>符号：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 区块引用1</span></span><br><span class="line"><span class="quote">&gt; 区块引用2</span></span><br><span class="line"><span class="quote">&gt; 区块引用3</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>语法笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>个人博客</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客系统搭建——经验总结</title>
    <url>/2019/12/17/Hexo+Github%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA%E2%80%94%E2%80%94%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191217/h1vQm1zqT88I.jpg?imageslim" alt="mark" style="zoom:150%;" />

<a id="more"></a>

<h1 id="Hexo博客系统搭建——经验总结"><a href="#Hexo博客系统搭建——经验总结" class="headerlink" title="Hexo博客系统搭建——经验总结"></a>Hexo博客系统搭建——经验总结</h1><p>Hexo是一个基于node.js制作的一个轻量静态博客工具，有很多的主题可供定制化，对中文用户也很友好。</p>
<p>主页：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191216/NLBzdnlHBqOC.png?imageslim" alt="mark"></p>
<p>下面我们就一起开始用Hexo来搭建属于自己的个人博客把。</p>
<p>【注】笔者用的是Windows系统，所以大部分操作是在cmd上完成的，如果使用Mac或者Linux应该大同小异，就不再赘述了。</p>
<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>因为Hexo是基于Node.js 开发的，所以肯定是需要安装node.js的，这个直接去官网下载安装包就行，安装后可以输入以下命令查看版本号，用于验证自己是否正确安装。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">$ node -v</span><br></pre></td></tr></table></figure>

<p>显示版本号表示成功安装：</p>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191216/HT6PTdeCeeEd.png?imageslim" alt="mark"></p>
<h2 id="安装cnpm"><a href="#安装cnpm" class="headerlink" title="安装cnpm"></a>安装cnpm</h2><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2>]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title>使用七牛云搭建个人免费图床</title>
    <url>/2019/12/17/%E4%BD%BF%E7%94%A8%E4%B8%83%E7%89%9B%E4%BA%91%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191217/gsPut9AvGaRr.jpg" alt="mark"></p>
<a id="more"></a>

]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>Hexo</tag>
        <tag>ECS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识——继承与多态</title>
    <url>/2019/12/15/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191216/adLGkvzIH0c5.jpg?imageslim" alt="mark"><br> <a id="more"></a> </p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>《Java核心技术 卷I》第五章 本章主要内容是Java中继承的相关知识。</p>
<h2 id="类、超类和子类"><a href="#类、超类和子类" class="headerlink" title="类、超类和子类"></a>类、超类和子类</h2><p>“is-a”关系是继承的一个明显特征</p>
<h3 id="定义子类"><a href="#定义子类" class="headerlink" title="定义子类"></a>定义子类</h3><p>关键字extends表示继承</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//添加方法和域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>已存在的类：父类、超类或基类</p>
<p>新类：子类、派生类或孩子类</p>
<p>子类比超类拥有的功能更加丰富，封装了更多数据、拥有更多功能。</p>
<h3 id="覆盖方法"><a href="#覆盖方法" class="headerlink" title="覆盖方法"></a>覆盖方法</h3><p>子类不能直接访问超类的私有域</p>
<p>super.方法 指示编译器调用超类的方法的特殊关键字</p>
<h3 id="子类构造器"><a href="#子类构造器" class="headerlink" title="子类构造器"></a>子类构造器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String name, <span class="keyword">double</span> salary, <span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name, salary, year, month, day);<span class="comment">//调用超类中含有name, salary, year, month, day参数的构造器</span></span><br><span class="line">    bonus = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>manage类不能访问employee类的私有域</p>
<p>使用super实现对超类构造器的调用，super必须是子类构造器的第一条语句</p>
<p>多态：一个变量对象可以指示多种实际类型的现象被称为<strong>多态</strong>，在运行时能够自动的选择调用哪个方法的现象称为<strong>动态绑定</strong>。</p>
<h3 id="继承层次"><a href="#继承层次" class="headerlink" title="继承层次"></a>继承层次</h3><p>由一个公共超类派生出来的所有类的集合</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>程序中出现超类对象对任何地方都可以引用子类对象置换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee e;</span><br><span class="line">e = <span class="keyword">new</span> Employee(...);<span class="comment">//</span></span><br><span class="line">e = <span class="keyword">new</span> Manger(...);<span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p>在Java程序设计语言中，对象变量是<strong>多态</strong>的。一个Employee变量既可以引用一个Employee类对象，也可以引用一个Employee类对任何一个子类的对象。</p>
<ol>
<li>理解多态性：可以理解为一个事物的多种形态。</li>
<li>何为多态性：对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）</li>
<li>多态的使用：虚拟方法调用 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。</li>
<li>多态性的使用前提：  ① 类的继承关系  ② 方法的重写</li>
<li>对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</li>
</ol>
<h3 id="instanceof-关键字"><a href="#instanceof-关键字" class="headerlink" title="instanceof 关键字"></a>instanceof 关键字</h3><p>有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。</p>
<p><strong>如何才能调用子类特有的属性和方法？</strong></p>
<p>答：向下转型：使用强制类型转换符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Man m1 = (Man)p2;</span><br></pre></td></tr></table></figure>

<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191217/oQ9iChTS5NSU.png?imageslim" alt="mark"></p>
<p>使用强转时，可能出现ClassCastException的异常，故引入instanceof关键字。</p>
<p><strong>instanceof关键字的使用</strong>：a instanceof A:判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false。</p>
<blockquote>
<p>使用情境：为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。<br>如果 a instanceof A返回true,则 a instanceof B也返回true。其中，类B是类A的父类。</p>
</blockquote>
<p>需要注意的几个问题：</p>
<p>问题一：编译时通过，运行时不通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p3 = <span class="keyword">new</span> Woman();</span><br><span class="line">Man m3 = (Man)p3;</span><br></pre></td></tr></table></figure>

<p>问题二：编译通过，运行时也通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Woman();</span><br><span class="line">Person p = (Person)obj;</span><br></pre></td></tr></table></figure>

<p>问题三：编译不通过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Man m5 = <span class="keyword">new</span> Woman();</span><br><span class="line">String str = <span class="keyword">new</span> Date();</span><br></pre></td></tr></table></figure>

<p>子类继承父类</p>
<ul>
<li>若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的 同名方法，系统将不可能把父类里的方法转移到子类中。</li>
<li>对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的 实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量。</li>
</ul>
<h3 id="Object类结构分析"><a href="#Object类结构分析" class="headerlink" title="Object类结构分析"></a>Object类结构分析</h3><ol>
<li><p>Object类是所有Java类的根父类</p>
</li>
<li><p>如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类 </p>
</li>
<li><p>Object类中的功能(属性、方法)就具有通用性。</p>
<p>属性：无</p>
<p>方法：equals() / toString() / getClass() /hashCode() / clone() / finalize()/wait() 、notify()、notifyAll()</p>
</li>
<li><p>Object类只声明了一个空参的构造器</p>
</li>
</ol>
<p><strong>equals()</strong></p>
<ol>
<li><p>回顾 == 的使用</p>
<ul>
<li><p>可以使用在基本数据类型变量和引用数据类型变量中</p>
</li>
<li><p>如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）</p>
</li>
<li><p>如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</p>
</li>
<li><p>== 符号使用时，必须保证符号左右两边的变量类型一致</p>
</li>
</ul>
</li>
<li><p>equals()方法的使用</p>
<ul>
<li><p>是一个方法，而非运算符</p>
</li>
<li><p>只能适用于引用数据类型</p>
</li>
<li><p>Object类中equals()的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">	  &#125;</span><br><span class="line"><span class="comment">//Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同。</p>
</li>
<li><p>通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的”实体内容”是否相同。那么，我们就需要对Object类中的equals()进行重写。</p>
</li>
</ul>
</li>
<li><p>重写equals()方法的原则</p>
<ul>
<li><p>对称性：如果x.equals(y)返回是“true” ，那么y.equals(x)也应该返回是 “true”。</p>
</li>
<li><p>自反性：x.equals(x)必须返回是“true”。</p>
</li>
<li><p>传递性：如果x.equals(y)返回是“true” ，而且y.equals(z)返回是“true” ， 那么z.equals(x)也应该返回是“true”。</p>
</li>
<li><p>一致性：如果x.equals(y)返回是“true” ，只要x和y内容一直不变，不管你 重复x.equals(y)多少次，返回都是“true”。</p>
</li>
<li><p>任何情况下，x.equals(null)，永远返回是“false” ；</p>
<p> x.equals(和x不同类型的对象)永远返回是“false”。</p>
</li>
</ul>
</li>
</ol>
<p><strong>toString()</strong></p>
<p>Object类中toString()的使用：</p>
<ol>
<li><p>当我们输出一个对象的引用时，实际上就是调用当前对象的toString()。</p>
</li>
<li><p>Object类中toString()的定义：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getClass().getName()+<span class="string">"@"</span>+Integer.toHexString(hashCode());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>像String、Date、File、包装类等都重写了Object类中的toString()方法。使得在调用对象的toString()时，返回”实体内容”信息。</li>
<li>自定义类也可以重写toString()方法，当调用此方法时，返回对象的”实体内容”。</li>
</ol>
<h3 id="Java中的JUnit单元测试"><a href="#Java中的JUnit单元测试" class="headerlink" title="Java中的JUnit单元测试"></a>Java中的JUnit单元测试</h3><p><strong>步骤：</strong></p>
<ol>
<li><p>选中当前工程 - 右键选择：build path - add libraries - JUnit 4 - 下一步</p>
</li>
<li><p>创建Java类，进行单元测试。此时的Java类要求：① 此类是public的  ②此类提供公共的无参的构造器</p>
</li>
<li><p>此类中声明单元测试方法。此时的单元测试方法：方法的权限是public,没有返回值，没有形参</p>
</li>
<li><p>此单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.junit.Test;</p>
</li>
<li><p>声明好单元测试方法以后，就可以在方法体内测试相关的代码。</p>
</li>
<li><p>写完代码以后，左键双击单元测试方法名，右键：run as - JUnit Test</p>
</li>
</ol>
<p><strong>说明：</strong></p>
<p>1.如果执行结果没有任何异常：绿条</p>
<p>2.如果执行结果出现异常：红条</p>
<h3 id="包装类的使用"><a href="#包装类的使用" class="headerlink" title="包装类的使用"></a>包装类的使用</h3><ol>
<li><p>Java提供了8种基本数据类型对应的包装类，使得基本数据类型的变量具有类的特征</p>
</li>
<li><p>掌握的：基本数据类型、包装类、String三者之间的相互转换</p>
</li>
</ol>
<p>总结：基本类型、包装与 String类间的转换:</p>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191218/dxFknG46u8Vy.png" alt="mark"></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java实战——客户管理软件项目</title>
    <url>/2019/12/13/Java%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%AE%A2%E6%88%B7%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191220/C8y9gctBLzJK.jpg" alt="mark"></p>
<a id="more"></a> 

<p><em>写在最前</em></p>
<p><em>经过了一段时间的学习，下面通过一个简单客户管理软件项目复习一下学过的知识点。</em></p>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ol>
<li>模拟实现一个基于文本界面的《客户信息管理软件》</li>
<li>进一步掌握编程技巧和调试技巧，熟悉面向对象编程</li>
<li>主要涉及以下知识点：</li>
</ol>
<ul>
<li>类结构的使用：属性、方法及构造器</li>
<li>对象的创建与使用</li>
<li>类的封装性</li>
<li>声明和使用数组</li>
<li>数组的插入、删除和替换</li>
<li>关键字的使用：this</li>
</ul>
<h3 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h3><p>模拟实现基于文本界面的《客户信息管理软件》。</p>
<p>该软件能够实现对客户对象的插入、修改和删除（用数组实现），并能够打印客户明细表。</p>
<h3 id="软件设计结构"><a href="#软件设计结构" class="headerlink" title="软件设计结构"></a>软件设计结构</h3><p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191220/qYwOgp2EMTRY.png" alt="mark"></p>
<ol>
<li>CustomerView为主模块，负责菜单的显示和处理用户操作</li>
<li>CustomerList为Customer对象的管理模块，内部用数组管理一组Customer对象，并提供相应的添加、修改、删除和遍历方法，供CustomerView调用</li>
<li>Customer为实体对象，用来封装客户信息</li>
</ol>
<h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><h4 id="1-键盘访问的实现"><a href="#1-键盘访问的实现" class="headerlink" title="1. 键盘访问的实现"></a>1. 键盘访问的实现</h4><p>项目中提供了CMUtility.java类，可用来方便地实现键盘访问。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gaowei.endpoint.util;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">CMUtility工具类：</span></span><br><span class="line"><span class="comment">将不同的功能封装为方法，就是可以直接通过调用方法使用它的功能，而无需考虑具体的功能实现细节。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CMUtility</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	用于界面菜单的选择。该方法读取键盘，如果用户键入’1’-’5’中的任意字符，则方法返回。返回值为用户键入字符。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">readMenuSelection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            String str = readKeyBoard(<span class="number">1</span>, <span class="keyword">false</span>);</span><br><span class="line">            c = str.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">'1'</span> &amp;&amp; c != <span class="string">'2'</span> &amp;&amp; </span><br><span class="line">                c != <span class="string">'3'</span> &amp;&amp; c != <span class="string">'4'</span> &amp;&amp; c != <span class="string">'5'</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">"选择错误，请重新输入："</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	从键盘读取一个字符，并将其作为方法的返回值。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">readChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str = readKeyBoard(<span class="number">1</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	从键盘读取一个字符，并将其作为方法的返回值。</span></span><br><span class="line"><span class="comment">	如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">readChar</span><span class="params">(<span class="keyword">char</span> defaultValue)</span> </span>&#123;</span><br><span class="line">        String str = readKeyBoard(<span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> (str.length() == <span class="number">0</span>) ? defaultValue : str.charAt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	从键盘读取一个长度不超过2位的整数，并将其作为方法的返回值。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">readInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            String str = readKeyBoard(<span class="number">2</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                n = Integer.parseInt(str);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                System.out.print(<span class="string">"数字输入错误，请重新输入："</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	从键盘读取一个长度不超过2位的整数，并将其作为方法的返回值。</span></span><br><span class="line"><span class="comment">	如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">readInt</span><span class="params">(<span class="keyword">int</span> defaultValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            String str = readKeyBoard(<span class="number">2</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (str.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> defaultValue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                n = Integer.parseInt(str);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">                System.out.print(<span class="string">"数字输入错误，请重新输入："</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	从键盘读取一个长度不超过limit的字符串，并将其作为方法的返回值。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readString</span><span class="params">(<span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> readKeyBoard(limit, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	从键盘读取一个长度不超过limit的字符串，并将其作为方法的返回值。</span></span><br><span class="line"><span class="comment">	如果用户不输入字符而直接回车，方法将以defaultValue 作为返回值。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readString</span><span class="params">(<span class="keyword">int</span> limit, String defaultValue)</span> </span>&#123;</span><br><span class="line">        String str = readKeyBoard(limit, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> str.equals(<span class="string">""</span>)? defaultValue : str;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	用于确认选择的输入。该方法从键盘读取‘Y’或’N’，并将其作为方法的返回值。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">readConfirmSelection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            String str = readKeyBoard(<span class="number">1</span>, <span class="keyword">false</span>).toUpperCase();</span><br><span class="line">            c = str.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'Y'</span> || c == <span class="string">'N'</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(<span class="string">"选择错误，请重新输入："</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readKeyBoard</span><span class="params">(<span class="keyword">int</span> limit, <span class="keyword">boolean</span> blankReturn)</span> </span>&#123;</span><br><span class="line">        String line = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            line = scanner.nextLine();</span><br><span class="line">            <span class="keyword">if</span> (line.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (blankReturn) <span class="keyword">return</span> line;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (line.length() &lt; <span class="number">1</span> || line.length() &gt; limit) &#123;</span><br><span class="line">                System.out.print(<span class="string">"输入长度（不大于"</span> + limit + <span class="string">"）错误，请重新输入："</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> line;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-Customer类的设计"><a href="#2-Customer类的设计" class="headerlink" title="2. Customer类的设计"></a>2. Customer类的设计</h4><ul>
<li><p>按照设计要求编写Customer类，并编译。</p>
</li>
<li><p>在Customer 类中临时添加一个main方法中，作为单元测试方法。在方法中创建Customer对象，并调用对象的各个方法，以测试该类是否编写正确。</p>
</li>
</ul>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gaowei.endpoint.bean;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: Customer.java  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gaowei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span> com.gaowei.endpoint.bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Customer为实体类，用来封装客户信息 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019年12月11日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">	String name  ;<span class="comment">//客户姓名</span></span><br><span class="line">	<span class="keyword">char</span> gender  ;<span class="comment">//性别</span></span><br><span class="line">	<span class="keyword">int</span> age      ;<span class="comment">//年龄</span></span><br><span class="line">	String phone ;<span class="comment">//电话号码</span></span><br><span class="line">	String email ;<span class="comment">//电子邮箱</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getGender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> gender;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(<span class="keyword">char</span> gender)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.gender = gender;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> phone;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhone</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.phone = phone;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> email;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.email = email;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//super();</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(String name, <span class="keyword">char</span> gender, <span class="keyword">int</span> age, String phone, String email)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//super();</span></span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.gender = gender;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		<span class="keyword">this</span>.phone = phone;</span><br><span class="line">		<span class="keyword">this</span>.email = email;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-CustomerList类的设计"><a href="#3-CustomerList类的设计" class="headerlink" title="3. CustomerList类的设计"></a>3. CustomerList类的设计</h4><p><strong>CustomerList</strong>为Customer对象的管理模块，内部使用数组管理一组Customer对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gaowei.endpoint.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gaowei.endpoint.bean.Customer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: CustomerList.java  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gaowei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span> com.gaowei.endpoint.service</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: CustomerList为Customer对象的管理模块，内部使用数组管理一组Customer对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019年12月11日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Customer[] customers; <span class="comment">// 用来保存客户对象的数组</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">0</span>; <span class="comment">// 记录已保存客户对象的数量</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> gaowei</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@TODO</span> 测试功能用</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">/*	</span></span><br><span class="line"><span class="comment">	public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment">		CustomerList cList = new CustomerList(10);</span></span><br><span class="line"><span class="comment">		Customer aCustomer = new Customer("aa",'1', 18, "11","11");</span></span><br><span class="line"><span class="comment">		Customer bCustomer = new Customer("bb",'1', 18, "11","11");</span></span><br><span class="line"><span class="comment">		Customer cCustomer = new Customer("cc",'1', 18, "11","11");</span></span><br><span class="line"><span class="comment">		Customer dCustomer = new Customer("dd",'1', 18, "11","11");</span></span><br><span class="line"><span class="comment">		Customer eCustomer = new Customer("ee",'1', 18, "11","11");</span></span><br><span class="line"><span class="comment">		cList.addCustomer(aCustomer);</span></span><br><span class="line"><span class="comment">		cList.addCustomer(bCustomer);</span></span><br><span class="line"><span class="comment">		cList.addCustomer(cCustomer);</span></span><br><span class="line"><span class="comment">		cList.addCustomer(dCustomer);</span></span><br><span class="line"><span class="comment">		cList.addCustomer(eCustomer);</span></span><br><span class="line"><span class="comment">		Customer[] cust = cList.getAllCustomers();		</span></span><br><span class="line"><span class="comment">		System.out.println("加入成员后：");			</span></span><br><span class="line"><span class="comment">		System.out.println(cList.getTotal());</span></span><br><span class="line"><span class="comment">		for (int i = 0; i &lt; cust.length; i++) &#123;</span></span><br><span class="line"><span class="comment">			System.out.println(cust[i].getName());</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">				</span></span><br><span class="line"><span class="comment">		cList.deleteCustomer(2);</span></span><br><span class="line"><span class="comment">		cList.deleteCustomer(1);</span></span><br><span class="line"><span class="comment">		cust = cList.getAllCustomers();</span></span><br><span class="line"><span class="comment">		System.out.println("删去成员后：");	</span></span><br><span class="line"><span class="comment">		System.out.println(cList.getTotal());</span></span><br><span class="line"><span class="comment">		for (int i = 0; i &lt; cust.length; i++) &#123;</span></span><br><span class="line"><span class="comment">			System.out.println(cust[i].getName());</span></span><br><span class="line"><span class="comment">		&#125;		</span></span><br><span class="line"><span class="comment">		cList.replaceCustomer(1, aCustomer);</span></span><br><span class="line"><span class="comment">		cust = cList.getAllCustomers();</span></span><br><span class="line"><span class="comment">		System.out.println("替换成员后：");	</span></span><br><span class="line"><span class="comment">		System.out.println(cList.getTotal());</span></span><br><span class="line"><span class="comment">		for (int i = 0; i &lt; cust.length; i++) &#123;</span></span><br><span class="line"><span class="comment">			System.out.println(cust[i].getName());</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">			</span></span><br><span class="line"><span class="comment">		Customer fCustomer = new Customer();  </span></span><br><span class="line"><span class="comment">		fCustomer = cList.getCustomer(2);</span></span><br><span class="line"><span class="comment">		System.out.println(fCustomer.getName());</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@TODO</span> 用途：构造器，用来初始化customers数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> totalCustomer: 指定customers数组的最大空间</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CustomerList</span><span class="params">(<span class="keyword">int</span> totalCustomer)</span> </span>&#123;</span><br><span class="line">		customers = <span class="keyword">new</span> Customer[totalCustomer];</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@TODO</span> 将参数customer添加到数组中最后一个客户对象记录之后</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> customer 指定要添加的客户对象 </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 添加成功返回true；false表示数组已满，无法添加</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addCustomer</span><span class="params">(Customer customer)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(total == customers.length) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		customers[total] = customer;</span><br><span class="line">		total++;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@TODO</span> 用参数customer替换数组中由index指定的对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index 指定所替换对象在数组中的位置，从0开始</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> cust 指定替换的新客户对象 </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 替换成功返回true；false表示索引无效，无法替换</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replaceCustomer</span><span class="params">(<span class="keyword">int</span> index, Customer cust)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= total) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		customers[index] = cust;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@TODO</span> 从数组中删除参数index指定索引位置的客户对象记录</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index指定所删除对象在数组中的索引位置，从0开始</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 删除成功返回true；false表示索引无效，无法删除</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteCustomer</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= total) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; total; i++) &#123;</span><br><span class="line">			customers[i] = customers[i+<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		total--;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@TODO</span> 返回数组中记录的所有客户对象</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> Customer[] 数组中包含了当前所有客户对象，该数组长度与对象个数相同</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> Customer[] getAllCustomers() &#123;</span><br><span class="line">		Customer[] cust = <span class="keyword">new</span> Customer[total];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">			cust[i] = customers[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> cust;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@TODO</span> 返回参数index指定索引位置的客户对象记录</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index指定所要获取的客户在数组中的索引位置，从0开始</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 封装了客户信息的Customer对象</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Customer <span class="title">getCustomer</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		Customer customer = <span class="keyword">new</span> Customer();</span><br><span class="line">		customer = customers[index];</span><br><span class="line">		<span class="keyword">return</span> customer;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTotal</span><span class="params">()</span> </span>&#123;		</span><br><span class="line">		<span class="keyword">return</span> total;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-CustomerView类的设计"><a href="#4-CustomerView类的设计" class="headerlink" title="4. CustomerView类的设计"></a>4. CustomerView类的设计</h4><p><strong>CustomerView</strong>为主模块，负责菜单的显示和处理用户操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gaowei.endpoint.ui;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gaowei.endpoint.service.CustomerList;</span><br><span class="line"><span class="keyword">import</span> com.gaowei.endpoint.bean.Customer;</span><br><span class="line"><span class="keyword">import</span> com.gaowei.endpoint.util.CMUtility;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Title</span>: CustomerView.java  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> gaowei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span> com.gaowei.endpoint.ui</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: CustomerView为主模块，负责菜单的显示和处理用户操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019年12月11日</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> V1.0 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerView</span> </span>&#123;</span><br><span class="line">	CustomerList customerList = <span class="keyword">new</span> CustomerList(<span class="number">10</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@todo</span> 显示主菜单，响应用户输入，根据用户操作分别调用</span></span><br><span class="line"><span class="comment">	 * 		   其他相应的成员方法（如addNewCustomer），以完成客户信息处理。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enterMainMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> isFlag = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">while</span> (isFlag) &#123;</span><br><span class="line">			System.out.println(<span class="string">"\n-----------------客户信息管理软件-----------------\n"</span>);</span><br><span class="line">			System.out.println(<span class="string">"                   1 添 加 客 户"</span>);</span><br><span class="line">			System.out.println(<span class="string">"                   2 修 改 客 户"</span>);</span><br><span class="line">			System.out.println(<span class="string">"                   3 删 除 客 户"</span>);</span><br><span class="line">			System.out.println(<span class="string">"                   4 客 户 列 表"</span>);</span><br><span class="line">			System.out.println(<span class="string">"                   5 退       出\n"</span>);</span><br><span class="line">			System.out.print(<span class="string">"                   请选择(1-5)："</span>);</span><br><span class="line">			<span class="keyword">char</span> key = CMUtility.readMenuSelection();</span><br><span class="line">			<span class="keyword">switch</span> (key) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'1'</span>:</span><br><span class="line">				addNewCustomer();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'2'</span>:</span><br><span class="line">				modifyCustomer();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'3'</span>:</span><br><span class="line">				deleteCustomer();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'4'</span>:</span><br><span class="line">				listAllCustomers();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'5'</span>:</span><br><span class="line">				System.out.print(<span class="string">"是否确认退出(Y/N):"</span>);</span><br><span class="line">				<span class="keyword">if</span>( CMUtility.readConfirmSelection() == <span class="string">'Y'</span>)</span><br><span class="line">					isFlag = <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addNewCustomer</span><span class="params">()</span> </span>&#123;		</span><br><span class="line">		System.out.println(<span class="string">"---------------------添加客户---------------------"</span>);</span><br><span class="line">		System.out.print(<span class="string">"姓名："</span>);</span><br><span class="line">		String name = CMUtility.readString(<span class="number">5</span>);</span><br><span class="line">		System.out.print(<span class="string">"性别："</span>);</span><br><span class="line">		<span class="keyword">char</span> gender = CMUtility.readChar(<span class="string">'男'</span>);</span><br><span class="line">		System.out.print(<span class="string">"年龄："</span>);</span><br><span class="line">		<span class="keyword">int</span> age = CMUtility.readInt();</span><br><span class="line">		System.out.print(<span class="string">"电话："</span>);</span><br><span class="line">		String phone = CMUtility.readString(<span class="number">13</span>);</span><br><span class="line">		System.out.print(<span class="string">"邮箱："</span>);</span><br><span class="line">		String email = CMUtility.readString(<span class="number">30</span>);</span><br><span class="line">		Customer customer = <span class="keyword">new</span> Customer(name, gender, age, phone, email);</span><br><span class="line">		<span class="keyword">boolean</span> isFlag = customerList.addCustomer(customer);</span><br><span class="line">		<span class="keyword">if</span>(isFlag) &#123;</span><br><span class="line">			System.out.println(<span class="string">"---------------------添加完成---------------------"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"----------------记录已满,无法添加-----------------"</span>);</span><br><span class="line">		&#125;				</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">modifyCustomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"---------------------------修改客户---------------------------"</span>);</span><br><span class="line">		System.out.print(<span class="string">"请选择待修改客户编号(-1退出)："</span>);</span><br><span class="line">		<span class="keyword">int</span> index = CMUtility.readInt();</span><br><span class="line">		<span class="keyword">if</span>(index == -<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			</span><br><span class="line">			Customer[] customers = customerList.getAllCustomers();</span><br><span class="line">			Customer cust = customerList.getCustomer(index-<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(cust == <span class="keyword">null</span>) &#123;</span><br><span class="line">				System.out.println(<span class="string">"无法找到指定客户！"</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.print(<span class="string">"姓名"</span> + <span class="string">'('</span> + customers[index-<span class="number">1</span>].getName() + <span class="string">"):"</span>);</span><br><span class="line">			String name = CMUtility.readString(<span class="number">5</span>,customers[index-<span class="number">1</span>].getName());</span><br><span class="line">			System.out.print(<span class="string">"性别"</span> + <span class="string">'('</span> + customers[index-<span class="number">1</span>].getGender() + <span class="string">"):"</span>);</span><br><span class="line">			<span class="keyword">char</span> gender = CMUtility.readChar(customers[index-<span class="number">1</span>].getGender());</span><br><span class="line">			System.out.print(<span class="string">"年龄"</span> + <span class="string">'('</span> + customers[index-<span class="number">1</span>].getAge() + <span class="string">"):"</span>);</span><br><span class="line">			<span class="keyword">int</span> age = CMUtility.readInt(customers[index-<span class="number">1</span>].getAge());</span><br><span class="line">			System.out.print(<span class="string">"电话"</span> + <span class="string">'('</span> + customers[index-<span class="number">1</span>].getPhone() + <span class="string">"):"</span>);</span><br><span class="line">			String phone = CMUtility.readString(<span class="number">13</span>,customers[index-<span class="number">1</span>].getPhone());</span><br><span class="line">			System.out.print(<span class="string">"邮箱"</span> + <span class="string">'('</span> + customers[index-<span class="number">1</span>].getEmail() + <span class="string">"):"</span>);</span><br><span class="line">			String email = CMUtility.readString(<span class="number">30</span>,customers[index-<span class="number">1</span>].getEmail());</span><br><span class="line">			cust = <span class="keyword">new</span> Customer(name, gender, age, phone, email);</span><br><span class="line">			<span class="keyword">boolean</span> isflag = customerList.replaceCustomer(index - <span class="number">1</span>, cust);</span><br><span class="line">			<span class="keyword">if</span>(isflag) &#123;</span><br><span class="line">				System.out.println(<span class="string">"---------------------修改完成---------------------"</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">"----------无法找到指定客户,修改失败--------------"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteCustomer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"---------------------------删除客户---------------------------"</span>);</span><br><span class="line">		System.out.print(<span class="string">"请选择待删除客户编号(-1退出)："</span>);</span><br><span class="line">		<span class="keyword">int</span> index = CMUtility.readInt();</span><br><span class="line">		<span class="keyword">if</span>(index == -<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"确认是否删除(Y/N)："</span>);</span><br><span class="line">			<span class="keyword">char</span> key = CMUtility.readConfirmSelection();</span><br><span class="line">			<span class="keyword">if</span>(key == <span class="string">'Y'</span>) &#123;</span><br><span class="line">				<span class="keyword">boolean</span> isFlag = customerList.deleteCustomer(index - <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">if</span>(isFlag) &#123;</span><br><span class="line">					System.out.println(<span class="string">"---------------------------删除完成---------------------------"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					System.out.println(<span class="string">"----------无法找到指定客户,删除失败--------------"</span>);</span><br><span class="line">				&#125;			</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">listAllCustomers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"---------------------------客户列表---------------------------"</span>);</span><br><span class="line">		Customer[] cust = customerList.getAllCustomers();</span><br><span class="line">		System.out.println(<span class="string">"编号\t姓名\t性别\t年龄\t电话\t\t邮箱"</span>);</span><br><span class="line">		<span class="keyword">if</span>(cust.length == <span class="number">0</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">"客户列表为空！"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cust.length; i++) &#123;</span><br><span class="line">				System.out.println(i + <span class="number">1</span> + <span class="string">"\t"</span> + cust[i].getName()+ <span class="string">"\t"</span> + cust[i].getGender()+ <span class="string">"\t"</span> + cust[i].getAge()+ <span class="string">"\t"</span> + cust[i].getPhone() + <span class="string">"\t"</span> + <span class="string">"\t"</span> +cust[i].getEmail());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"-------------------------客户列表完成-------------------------"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		CustomerView cView = <span class="keyword">new</span> CustomerView();</span><br><span class="line">		cView.enterMainMenu();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h3><ul>
<li>添加客户</li>
</ul>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191220/UvKmCj6JcpKp.png" alt="mark"></p>
<ul>
<li>修改客户</li>
</ul>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191220/gKGYWGYD3UNo.png" alt="mark"></p>
<ul>
<li>删除客户</li>
</ul>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191220/JSP95pw9q2my.png" alt="mark"></p>
<ul>
<li>客户列表</li>
</ul>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191220/M8zeEb0qRsnT.png" alt="mark"></p>
<ul>
<li>退出</li>
</ul>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191220/L2GhdnbrDykV.png" alt="mark"></p>
]]></content>
      <categories>
        <category>项目实战</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>项目实战</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据结构与算法——队列</title>
    <url>/2019/12/10/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191217/QraeaDA9hLep.jpg?imageslim" alt="mark"></p>
<a id="more"></a> 

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191216/jhIm0HhcKYbY.png?imageslim" alt="mark"></p>
<ol>
<li>队列是一个有序列表，可以用<strong>数组</strong>或是<strong>链表</strong>来实现。</li>
<li>遵循<strong>先入先出</strong>的原则。即：先存入队列的数据，要先取出。后存入的要后取出</li>
</ol>
<h2 id="数组模拟队列"><a href="#数组模拟队列" class="headerlink" title="数组模拟队列"></a>数组模拟队列</h2><p>使用数组模拟队列的方法需要两个变量front、rear分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">front = -<span class="number">1</span>; <span class="comment">// 指向队列头部，分析出front是指向队列头的前一个位置.</span></span><br><span class="line">rear = -<span class="number">1</span>; <span class="comment">// 指向队列尾，指向队列尾的数据(即就是队列最后一个数据)</span></span><br></pre></td></tr></table></figure>

<p>利用这两个变量可以进行<strong>队列空</strong>、<strong>队列满</strong>、<strong>数据入队列</strong>、<strong>数据出队列</strong>的判断。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用数组模拟队列-编写一个ArrayQueue类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">// 表示数组的最大容量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> front; <span class="comment">// 队列头</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> rear; <span class="comment">// 队列尾</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] arr; <span class="comment">// 该数据用于存放数据, 模拟队列</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建队列的构造器</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span> </span>&#123;</span><br><span class="line">		maxSize = arrMaxSize;</span><br><span class="line">		arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">		front = -<span class="number">1</span>; <span class="comment">// 指向队列头部，分析出front是指向队列头的前一个位置.</span></span><br><span class="line">		rear = -<span class="number">1</span>; <span class="comment">// 指向队列尾，指向队列尾的数据(即就是队列最后一个数据)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断队列是否满</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rear == maxSize - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断队列是否为空</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rear == front;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加数据到队列</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断队列是否满</span></span><br><span class="line">		<span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"队列满，不能加入数据~"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		rear++; <span class="comment">// 让rear 后移</span></span><br><span class="line">		arr[rear] = n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取队列的数据, 出队列</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断队列是否空</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			<span class="comment">// 通过抛出异常</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空，不能取数据"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		front++; <span class="comment">// front后移</span></span><br><span class="line">		<span class="keyword">return</span> arr[front];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示队列的所有数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 遍历</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"arr[%d]=%d\n"</span>, i, arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示队列的头数据， 注意不是取出数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arr[front + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h2><p>对于上面方式创建的数组队列，有一个非常致命的问题，队列无法循环使用，为了解决这个问题我们引入取模操作，利用数组模拟一个环形队列，使得队列能够一直使用。</p>
<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191216/t221VHd7yIl6.png?imageslim" alt="mark"></p>
<p>如上图分析所示，变量front和rear需要做一个变化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素 </span></span><br><span class="line"><span class="comment">//front 的初始值 = 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> front; </span><br><span class="line"><span class="comment">//rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.</span></span><br><span class="line"><span class="comment">//rear 的初始值 = 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rear; <span class="comment">// 队列尾</span></span><br></pre></td></tr></table></figure>

<p>建立循环队列的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleArray</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">// 表示数组的最大容量</span></span><br><span class="line">	<span class="comment">//front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素 </span></span><br><span class="line">	<span class="comment">//front 的初始值 = 0</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> front; </span><br><span class="line">	<span class="comment">//rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.</span></span><br><span class="line">	<span class="comment">//rear 的初始值 = 0</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> rear; <span class="comment">// 队列尾</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] arr; <span class="comment">// 该数据用于存放数据, 模拟队列</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CircleArray</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span> </span>&#123;</span><br><span class="line">		maxSize = arrMaxSize;</span><br><span class="line">		arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 判断队列是否满</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (rear  + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 判断队列是否为空</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> rear == front;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 添加数据到队列</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断队列是否满</span></span><br><span class="line">		<span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"队列满，不能加入数据~"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//直接将数据加入</span></span><br><span class="line">		arr[rear] = n;</span><br><span class="line">		<span class="comment">//将 rear 后移, 这里必须考虑取模</span></span><br><span class="line">		rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取队列的数据, 出队列</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断队列是否空</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			<span class="comment">// 通过抛出异常</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空，不能取数据"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 这里需要分析出 front是指向队列的第一个元素</span></span><br><span class="line">		<span class="comment">// 1. 先把 front 对应的值保留到一个临时变量</span></span><br><span class="line">		<span class="comment">// 2. 将 front 后移, 考虑取模</span></span><br><span class="line">		<span class="comment">// 3. 将临时保存的变量返回</span></span><br><span class="line">		<span class="keyword">int</span> value = arr[front];</span><br><span class="line">		front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 显示队列的所有数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 遍历</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			System.out.println(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 思路：从front开始遍历，遍历多少个元素</span></span><br><span class="line">		<span class="comment">// 动脑筋</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; front + size() ; i++) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"arr[%d]=%d\n"</span>, i % maxSize, arr[i % maxSize]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 求出当前队列有效数据的个数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// rear = 2</span></span><br><span class="line">		<span class="comment">// front = 1</span></span><br><span class="line">		<span class="comment">// maxSize = 3 </span></span><br><span class="line">		<span class="keyword">return</span> (rear + maxSize - front) % maxSize;   </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 显示队列的头数据， 注意不是取出数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 判断</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arr[front];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据结构与算法——排序</title>
    <url>/2019/12/09/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191216/H8299vPG1R1R.jpg?imageslim" alt="mark"></p>
<a id="more"></a> 

<h1 id="初级排序"><a href="#初级排序" class="headerlink" title="初级排序"></a>初级排序</h1><p>《算法（第四版）》 第二章第一节 本章主要内容是选择排序、插入排序以及shell排序。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>不断选择剩余元素中的最小者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span> <span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>;  j &lt; N; j++)</span><br><span class="line">                <span class="keyword">if</span>(less(a[j], a[min]))	min = j;</span><br><span class="line">            exch(a, i, min); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(n^2)</p>
<p>运行时间与输入无关，有序数组同样需要等长时间。</p>
<p>数据的移动是最少的，N次交换——交换次数与数组长度是线性关系。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>每次都把当前值放入该值前面部分</p>
<p>插入排序时间取决于输入中元素的初始顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = a.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; less(a[j],a[j-<span class="number">1</span>]); j--)</span><br><span class="line">                exch(a, j, j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>使数组中任意间隔为h的元素都是有序的。</p>
<p>通过提升速度来解决其他方式无法解决的问题是研究算法的设计和性能的主要原因之一。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//Shell排序算法</span></span><br><span class="line">	<span class="keyword">int</span> N = a.length;</span><br><span class="line">	<span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(h &lt; N/<span class="number">3</span>) h = <span class="number">3</span>*h + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(h &gt;= <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = h; i &lt; N; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; less(a[j],a[j-h]); j -= h)</span><br><span class="line">               exch(a, j, j-h);</span><br><span class="line">		&#125;</span><br><span class="line">		h = h/<span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并：将两个有序的数组归并成一个更大的有序数组。</p>
<p>优点：任意长度为N的数组排序所需时间和NlogN成正比</p>
<p>缺点：所需的额外空间和N成正比</p>
<h2 id="原地归并的抽象方法"><a href="#原地归并的抽象方法" class="headerlink" title="原地归并的抽象方法"></a>原地归并的抽象方法</h2>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础知识——对象和类</title>
    <url>/2019/12/09/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E2%80%94%E2%80%94%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</url>
    <content><![CDATA[<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191216/XxQail85b7FQ.jpg?imageslim" alt="mark"> </p>
<a id="more"></a> 

<h1 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h1><p>《Java核心技术 卷I》第四章 本章主要内容是Java中对象和类的知识。</p>
<h2 id="静态与与静态方法"><a href="#静态与与静态方法" class="headerlink" title="静态与与静态方法"></a>静态与与静态方法</h2><h3 id="静态域"><a href="#静态域" class="headerlink" title="静态域"></a>静态域</h3><p>每个类中只有一个这样的域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>静态域属于类，不属于任何独立的对象。静态域其实是类域。</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>静态方法不能向对象实施操作，没有隐式的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.pow(x,a)</span><br></pre></td></tr></table></figure>

<p>静态方法不能访问实例域，不能操作对象，但是可以访问静态域。</p>
<p>建议通过类对象的引用来调用方法。</p>
<h3 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pulic <span class="class"><span class="keyword">class</span> <span class="title">Math</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.1416926</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><p>不需要使用对象调用静态方法。</p>
<h2 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h2><ul>
<li>Java程序设计语言总是采用按值调用</li>
<li>方法得到的所有参数值都是拷贝</li>
<li>方法不能修改传递给它的任何参数变量的内容</li>
</ul>
<p>对于对象引用作为参数，对象引用以及其他的拷贝同时引用同一个对象，对象引用是按值传递的。</p>
<p>总结Java中方法参数的使用情况</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数（数值型或布尔型）</li>
<li>一个方法可以改变一个对象参数的状态</li>
<li>一个方法不能让对象参数引用一个新的对象</li>
</ul>
<h2 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h2><h3 id="重载-overloading"><a href="#重载-overloading" class="headerlink" title="重载(overloading)"></a>重载(overloading)</h3><p>多个方法有相同的名字，不同的参数。</p>
<p>重载解析：编译器用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法，如果找不到，就会产生编译错误。</p>
<h3 id="默认域初始化"><a href="#默认域初始化" class="headerlink" title="默认域初始化"></a>默认域初始化</h3><p>如果不显式的给域赋初值，自动的赋为默认值，数值为0，布尔值为false，对象引用为null。</p>
<h3 id="无参数构造器"><a href="#无参数构造器" class="headerlink" title="无参数构造器"></a>无参数构造器</h3><p>编写类没有编写构造函数——》系统提供无参数构造函数</p>
<p>类中有构造器，但是无无参数构造函数——》构造对象时不提供参数被视为不合法</p>
<h3 id="调用另一个构造器"><a href="#调用另一个构造器" class="headerlink" title="调用另一个构造器"></a>调用另一个构造器</h3><p>关键词this引用方法的隐式参数</p>
<p>构造器中使用this(…)表示，构造器将调用同一个类的另一个构造器，可以用于对公共部分的构造器代码的简化。</p>
<h3 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h3><ul>
<li>在构造域中设置值</li>
<li>在声明中赋值</li>
<li>在初始化块中被初始化</li>
</ul>
<p>只要构造类对象，初始化块就被执行，先运行初始化块，再运行构造器的主体部分。</p>
<p>下面是调用构造器的具体处理步骤</p>
<ol>
<li>所有数据域被初始化为默认值（0、false、或者null）</li>
<li>按照在类的声明中出现的次序，依次执行所有域的初始化语句和初始化块</li>
<li>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体</li>
<li>执行这个构造器的主体</li>
</ol>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>使用包可以确保类名的唯一性。</p>
<p>从编译的角度看，嵌套的包之间没有任何关系。</p>
<h3 id="类的导入"><a href="#类的导入" class="headerlink" title="类的导入"></a>类的导入</h3><p>使用import语句导入一个特定的类或者整个包。</p>
<p>或者在每个类名之前添加完整包名。</p>
<h3 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br></pre></td></tr></table></figure>

<p>就可以使用System类的静态方法和静态域，不必加类名前缀。</p>
<h3 id="将类放入包中"><a href="#将类放入包中" class="headerlink" title="将类放入包中"></a>将类放入包中</h3><p>将包的名字放在源文件的开头，包中定义类的代码之前。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.horstman.corejava</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果没有package语句，那么类被放置在默认包(default package)中。</p>
<h2 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h2><p>类存储在文件系统子目录中，类的路径必须与包名匹配。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据结构和算法——稀疏矩阵</title>
    <url>/2019/12/05/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191216/Q8uEsQH3g5hV.jpg?imageslim" alt="mark"></p>
<a id="more"></a> 

<h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><p><img src="http://q2fz8l8jw.bkt.clouddn.com/blog/20191216/c57v4gQbgVoF.png?imageslim" alt="mark"></p>
<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p>
<p>稀疏数组的处理方法是:</p>
<ol>
<li><p>记录数组一共有几行几列，有多少个不同的值</p>
</li>
<li><p>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</p>
</li>
</ol>
<h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>使用稀疏数组，来保留类似前面的二维数组(棋盘、地图等等)<br>把稀疏数组存盘，并且可以从新恢复原来的二维数组数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建一个原始的二维数组 11 * 11</span></span><br><span class="line">		<span class="comment">// 0: 表示没有棋子， 1 表示 黑子 2 表蓝子</span></span><br><span class="line">		<span class="keyword">int</span> chessArr1[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">		chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">		chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">		chessArr1[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line">		chessArr1[<span class="number">6</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 输出原始的二维数组</span></span><br><span class="line">		System.out.println(<span class="string">"原始的二维数组~~"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr1) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">				System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将二维数组 转 稀疏数组的思</span></span><br><span class="line">		<span class="comment">// 1. 先遍历二维数组 得到非0数据的个数</span></span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">					sum++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 创建对应的稀疏数组</span></span><br><span class="line">		<span class="keyword">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">		<span class="comment">// 给稀疏数组赋值</span></span><br><span class="line">		sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">		sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">		sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 遍历二维数组，将非0的值存放到 sparseArr中</span></span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//count 用于记录是第几个非0数据</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">					count++;</span><br><span class="line">					sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">					sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">					sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 输出稀疏数组的形式</span></span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(<span class="string">"得到稀疏数组为~~~~"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"%d\t%d\t%d\t\n"</span>, sparseArr[i][<span class="number">0</span>], sparseArr[i][<span class="number">1</span>], sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将稀疏数组 --》 恢复成 原始的二维数组</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 *  1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 = int [11][11]</span></span><br><span class="line"><span class="comment">			2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">			chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 输出恢复后的二维数组</span></span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(<span class="string">"恢复后的二维数组"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr2) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">				System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong></p>
<p><img src="image-20191205193140618.png" alt="image-20191205193140618.png"></p>
<h3 id="习题要求"><a href="#习题要求" class="headerlink" title="习题要求"></a>习题要求</h3><ol>
<li>在前面的基础上，将稀疏数组保存到磁盘上，比如 map.data</li>
<li>恢复原来的数组时，读取map.data 进行恢复</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.sparsearray;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> javax.print.DocFlavor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 创建一个原始的二维数组 11 * 11</span></span><br><span class="line">		<span class="comment">// 0: 表示没有棋子， 1 表示 黑子 2 表蓝子</span></span><br><span class="line">		<span class="keyword">int</span> chessArr1[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">		chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">		chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">		chessArr1[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line">		chessArr1[<span class="number">6</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 输出原始的二维数组</span></span><br><span class="line">		System.out.println(<span class="string">"原始的二维数组~~"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr1) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">				System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将二维数组 转 稀疏数组的思</span></span><br><span class="line">		<span class="comment">// 1. 先遍历二维数组 得到非0数据的个数</span></span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">					sum++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2. 创建对应的稀疏数组</span></span><br><span class="line">		<span class="keyword">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">		<span class="comment">// 给稀疏数组赋值</span></span><br><span class="line">		sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">		sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">		sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 遍历二维数组，将非0的值存放到 sparseArr中</span></span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//count 用于记录是第几个非0数据</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">					count++;</span><br><span class="line">					sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">					sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">					sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将稀疏矩阵保存到磁盘上</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 输出稀疏数组的形式</span></span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(<span class="string">"得到稀疏数组为~~~~"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"%d\t%d\t%d\t\n"</span>, sparseArr[i][<span class="number">0</span>], sparseArr[i][<span class="number">1</span>], sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将稀疏数组存储到文件map.data中</span></span><br><span class="line">        saveData(sparseArr);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">//从map.data文件中读取稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] sparseArr1 =getData();</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将稀疏数组 --》 恢复成 原始的二维数组</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 *  1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 = int [11][11]</span></span><br><span class="line"><span class="comment">			2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr1[<span class="number">0</span>][<span class="number">0</span>]][sparseArr1[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr1.length; i++) &#123;</span><br><span class="line">			chessArr2[sparseArr1[i][<span class="number">0</span>]][sparseArr1[i][<span class="number">1</span>]] = sparseArr1[i][<span class="number">2</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 输出恢复后的二维数组</span></span><br><span class="line">		System.out.println();</span><br><span class="line">		System.out.println(<span class="string">"恢复后的二维数组"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr2) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">				System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">saveData</span><span class="params">(<span class="keyword">int</span>[][] arr)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">	        </span><br><span class="line">	        File file = <span class="keyword">new</span> File(<span class="string">"I:\\eclipse-workspace\\DataStructures\\map.data"</span>);</span><br><span class="line">	        PrintWriter pw = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> FileWriter(file));</span><br><span class="line">	        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; arr.length; i++)&#123;</span><br><span class="line">	            pw.println(arr[i][<span class="number">0</span>]+<span class="string">","</span>+arr[i][<span class="number">1</span>]+<span class="string">","</span>+arr[i][<span class="number">2</span>]);</span><br><span class="line">	            pw.flush();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	    </span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getData()<span class="keyword">throws</span> IOException&#123;</span><br><span class="line">	 </span><br><span class="line">	        File file = <span class="keyword">new</span> File(<span class="string">"I:\\eclipse-workspace\\DataStructures\\map.data"</span>);</span><br><span class="line">	        FileReader fr = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">	        BufferedReader br = <span class="keyword">new</span> BufferedReader(fr);</span><br><span class="line">	        String len=br.readLine();</span><br><span class="line">	        String[] str = len.split(<span class="string">","</span>);</span><br><span class="line">	        <span class="keyword">int</span>[][] ch = <span class="keyword">new</span>  <span class="keyword">int</span>[Integer.parseInt(str[<span class="number">2</span>])+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">	        ch[<span class="number">0</span>][<span class="number">0</span>] = Integer.parseInt(str[<span class="number">0</span>]);</span><br><span class="line">	        ch[<span class="number">0</span>][<span class="number">1</span>] = Integer.parseInt(str[<span class="number">1</span>]);</span><br><span class="line">	        ch[<span class="number">0</span>][<span class="number">2</span>] = Integer.parseInt(str[<span class="number">2</span>]);</span><br><span class="line">	        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">	        <span class="keyword">while</span>((len=br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">	            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">	                String[] str2 = len.split(<span class="string">","</span>);</span><br><span class="line">	                ch[temp][i] = Integer.parseInt(str2[i]);</span><br><span class="line">	            &#125;</span><br><span class="line">	            temp++;</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">return</span> ch;</span><br><span class="line">	    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<p><img src="image-20191205193101382.png" alt="image-20191205193101382"></p>
<p><img src="image-20191205193155714.png" alt="image-20191205193140618"></p>
]]></content>
  </entry>
</search>
